<!DOCTYPE HTML>
<html lang="en" class="mocha sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Chaotic 4.0 - Garuda&#x27;s infra documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Contains the documentation for the Garuda Linux infrastructure.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".././theme/mdbook-admonish.css">
        <link rel="stylesheet" href=".././theme/catppuccin.css">
        <link rel="stylesheet" href=".././theme/catppuccin-admonish.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "mocha";
            const default_dark_theme = "mocha";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('mocha')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="latte">Latte</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="frappe">Frappé</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="macchiato">Macchiato</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mocha">Mocha</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Garuda&#x27;s infra documentation</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/garuda-linux/infrastructure-nix" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-code-fork"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chaotic-aur-infra-40"><a class="header" href="#chaotic-aur-infra-40">Chaotic-AUR infra 4.0</a></h1>
<p>This is a manual for handling our new Chaotic-AUR infrastructure, which is based on GitLab CI and GitHub Actions.
It is powering the <code>garuda</code> repository, which contains all PKGBUILDs and other necessary files to build packages for
Garuda Linux.
Content has mostly been pasted from the original documentation for visibility.</p>
<h2 id="reasoning"><a class="header" href="#reasoning">Reasoning</a></h2>
<p>Our previous build tools, the so-called <a href="https://github.com/chaotic-aur/toolbox">toolbox</a> was initially created by
@pedrohlc to deal with one issue: having a lot of packages to compile while not having many maintainers for all of the
packages.
Additionally, Chaotic-AUR has quite inhomogeneous builders: servers, personal devices, and one HPC which all need to be
integrated somehow.
The toolbox had a nice approach to this - keeping things as KISS as possible and using Git to distribute package builds
between builders. These would then grab builds according to their activated routines. While this works fairly well, it
had a few problems which we tried to get rid of in the new version.
A few key ideas about this new setup:</p>
<ul>
<li>Since we like working with CI a lot besides it providing great enhancement for automating boring tasks as well as
making the whole process more transparent to the public as well, it was clear CI should be a major part of it.</li>
<li>The system should have a scheduler that distributes build tasks to nodes, which prevents useless build routines and
enables nodes to grab jobs whenever they are queued.</li>
<li>The tools should be available as Docker containers to make them easy to use on other systems than Arch.</li>
<li>All logic besides the scheduler (which is written in TypeScript using BullMQ) should be written in Bash</li>
</ul>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How it works</a></h2>
<p>The new system consists of three integral parts:</p>
<ul>
<li>The CI (which can be both GitLab CI and GitHub Actions!) handles PKGBUILDs, their changes, and figuring out what to
build, utilizing a Chaotic Manager container to schedule packages via the central Redis instance.</li>
<li>The central Redis instance storing information about currently scheduled builds.</li>
<li>The <a href="https://gitlab.com/garuda-linux/tools/chaotic-manager">Chaotic Manager</a> which is used to add new builds to the
queue and execute them via the main manager container. All containers have SSH-tunneled access to the Redis instance,
enabling the build containers to grab new builds whenever they enter the queue.</li>
</ul>
<p>Compared to Infra 3.0, this means we have the following key differences:</p>
<ul>
<li>We no longer have package lists but a repository full of PKGBUILD folders. These PKGBUILDs are getting pulled either
from AUR once a package has been updated or updated manually in case a Git repository and its tags serve as a source.</li>
<li>No more dedicated builders (might change in the future, eg. for heavy builds?) but a common build queue.</li>
<li>Routines are no longer necessary - CI determines and adds packages to the schedule as needed. The only "routine-like"
thing we have is the CI schedule, executing tasks like PKGBUILD or version updates.</li>
<li>The actual logic behind the build process (like <code>interfere.sh</code> or database management) was moved to
the <a href="https://gitlab.com/garuda-linux/tools/chaotic-manager/-/tree/main/builder-container?ref_type=heads">builder container of Chaotic Manager</a> -
this one updates daily/on-commit and gets pulled regularly by the Manager instance.</li>
<li>Live-updating build logs will be available via CI - multiple revisions instead of only the latest.</li>
<li>The interfere repo is no longer needed, instead, package builds can be configured via the <code>.CI</code> folder in their
respective PKGBUILD folders. All known interfere types can be put here (eg. <code>PKGBUILD.append</code> or <code>prepare.sh</code>),
keeping existing interferes working.</li>
<li>The CI's behavior concerning each package can be configured via a <code>config</code> file in the <code>.CI</code> folder: this file stores
information like PKGBUILD source (it can be AUR or something different), PKGBUILD timestamp on AUR, most recent Git
commit as well as settings like whether to push a PKGBUILD change back to AUR.</li>
<li>PKGBUILD changes can now be reviewed in case of major (all changes other than pkgver, hashes, pkgrel) updates - CI
automatically creates a PR containing the changes for human review.</li>
<li>Adding and removing packages is entirely controlled via Git - after adding a new PKGBUILD folder via commit, the
corresponding package will automatically be deployed. Removing it has the opposite effect.</li>
</ul>
<h2 id="workflows-and-information"><a class="header" href="#workflows-and-information">Workflows and information</a></h2>
<h3 id="adding-packages"><a class="header" href="#adding-packages">Adding packages</a></h3>
<p>Adding packages is as easy as creating a new folder named after the <code>$pkgbase</code> of the package. Put the PKGBUILD and all
other required files in here.
Adding AUR packages is therefore as simple as cloning its repo and removing the <code>.git</code> folder.
CI relies on <code>.SRCINFO</code> files to parse most information, therefore, it is important to have them in place and up-to-date
in case of self-managed packages.
Finally, add a <code>.CI</code> folder containing the basic config (<code>CI_PKGBUILD_SOURCE</code> is required in case its external package,
self-managed PKBUILDs don't need it), commit any changes, and push the changes back to the main branch.
Please follow the <a href="https://www.conventionalcommits.org/en/v1.0.0/">conventional commit convention</a> while doing
so (<a href="https://github.com/commitizen/cz-cli">cz-cli</a> can help with that!). This means commits like:</p>
<ul>
<li><code>feat($pkgname): init</code></li>
<li><code>fix($pkgname): fix xyz</code></li>
<li><code>chore($pkgname): update PKGBUILD</code></li>
<li><code>ci(config): update</code></li>
</ul>
<p>This not only helps with having a uniform commit history, it also allows automatic changelog generation.</p>
<h3 id="removing-packages"><a class="header" href="#removing-packages">Removing packages</a></h3>
<p>This can be done by removing the folder containing a package's PKGBUILD. A cleanup job will then automatically remove
any obsolete package via the <code>on-commit</code> pipeline run. This will also consider any split packages that a package might
produce.
Renaming folders does also count as removing packages.</p>
<h3 id="on-commit-pipeline"><a class="header" href="#on-commit-pipeline">On-commit pipeline</a></h3>
<p>Whenever pushing a new commit, the CI pipeline will carry out the following actions:</p>
<ul>
<li>Checking when the last <code>scheduled</code> tag was created. This is used to determine which packages need to be scheduled.</li>
<li>It parses each commit for a <code>[deploy $foldername]</code> string, only accepting valid values derived from the existing
PKGBUILD folders. <code>[deploy all]</code> is a valid parameter as well. Misspelling <code>$pkgname</code> is a fatal error here. Any
issues must be fixed and force-pushed.</li>
<li>Then, the changed files are parsed. This also includes removed packages. Any changed relevant folder content will
cause a package deployment of the corresponding package.</li>
<li>The final action is to build the schedule parameters (handing it over to the scheduled job via artifacts) and remove
all obsolete packages in case an earlier step is detected.</li>
<li>In case all of these actions succeed, the <code>scheduled</code> tag gets updated, so we can refer to it on a later pipeline run.</li>
</ul>
<h3 id="on-schedule-pipeline"><a class="header" href="#on-schedule-pipeline">On-schedule pipeline</a></h3>
<h4 id="half-hourly"><a class="header" href="#half-hourly">Half-hourly</a></h4>
<p>Every half an hour, the on-schedule pipeline will carry out a few tasks:</p>
<ul>
<li>Updating the CI template from the template repository (in case this is enabled via <code>.ci/config</code>)</li>
<li>Check if the scheduled tag does not exist or scheduled does not point to HEAD (in this case abort mission!)</li>
<li>Check whether the .state worktree containing the state of the packages exists, if it does, it sets it up. Otherwise,
it re-creates it from scratch (e.g., on force push)</li>
<li>Check whether the last commit is automated (containing "chore(packages): update packages [skip ci]"), if yes, the
commit resulting from the schedule will overwrite it to keep the commit history clean.</li>
<li>Collect AUR timestamps of packages to determine whether a PKGBUILD changed</li>
<li>Loop through each valid package and carry out the following actions:
<ul>
<li>Read the <code>.CI/config</code> file to gain information about the package configuration (e.g., whether to manage the AUR
repository, the source of the PKGBUILD, etc.)</li>
<li>Update PKGBUILD in the following cases:
<ul>
<li>CI_PKGBUILD_SOURCE is set to <code>gitlab</code>: Updates the PKGBUILD from the GitLab repository tags</li>
<li>CI_PKGBUILD_SOURCE is set to <code>aur</code>: Updates the PKGBUILD from the AUR repository, pulling in the git repo and
replacing the existing files with the new ones.
If the AUR timestamp could not be collected earlier, the package update gets skipped.</li>
<li>CI_PKGBUILD_SOURCE is not set to <code>gitlab</code> or <code>aur</code>:
tries to update the PKGBUILD by pulling the repository specified in CI_PKGBUILD_SOURCE.
In case cloning was not successful after 2 tries, the update process gets skipped.</li>
</ul>
</li>
<li>In case CI_GIT_COMMIT is set in the packages configuration variables, the latest commit of the git URL set in
the <code>source</code> section of the PKGBUILD is
updated. If it differs, schedule a build.</li>
<li>In case a custom hook exists (<code>.CI/update.sh</code> inside the package directory), it gets executed - this can be used
for
updating PKGBUILDs with a custom script.</li>
<li>Writing needed variables back to <code>.CI/config</code> (eg. Git hash)</li>
</ul>
</li>
<li>Either update the PKGBUILD silently in case of minor changes, create a PR for review in case of major updates (and
only if <code>CI_HUMAN_REVIEW</code> is true)
<ul>
<li>Updates are only considered if diff actually reports changes between current PKGBUILD folder and AUR PKGBUILD repo</li>
<li>Any change made to the source files is detected, this however does <em>not</em> detect malicious changes in the upstream
project source that the package builds</li>
</ul>
</li>
<li>The state worktree gets updated with new information</li>
<li>Schedule parameters are getting built and handed over to the scheduled job via artifact</li>
<li>Obsolete branches (eg. merged review PRs) are getting pruned</li>
<li>The scheduled tag gets updated again</li>
</ul>
<h4 id="daily"><a class="header" href="#daily">Daily</a></h4>
<p>A daily pipeline schedule has been added for specific packages which generate their <code>pkgver</code> dynamically.
To make use of it, set <code>CI_ON_TRIGGER=daily</code> inside the <code>.CI/config</code> file of the package.</p>
<h3 id="manual-scheduling"><a class="header" href="#manual-scheduling">Manual scheduling</a></h3>
<h4 id="scheduling-packages-without-git-commits"><a class="header" href="#scheduling-packages-without-git-commits">Scheduling packages without git commits</a></h4>
<p>Packages can be added to the schedule manually by going to
the <a href="https://gitlab.com/chaotic-aur/pkgbuilds/-/pipelines">pipeline runs</a> page, selecting "Run pipeline" and
adding <code>PACKAGES</code> as a variable with the package names as its value. The pipeline will then pick up the packages and
schedule them.
<code>PACKAGES</code> can also be set to <code>all</code> to schedule all packages. In case one or many packages are getting scheduled, it
needs to follow the format <code>pkgname1:pkgname2:pkgname3</code>.</p>
<h4 id="running-scheduled-pipelines-on-demand"><a class="header" href="#running-scheduled-pipelines-on-demand">Running scheduled pipelines on-demand</a></h4>
<p>This can be done by going to the <a href="https://gitlab.com/chaotic-aur/pkgbuilds/-/pipeline_schedules">pipeline runs</a> page,
selecting "Run pipeline" (the play symbol). A link to the pipeline page will be provided, where the pipeline logs can be
obtained.</p>
<h3 id="adding-interfere"><a class="header" href="#adding-interfere">Adding interfere</a></h3>
<p>Put the required interfere file in the <code>.CI</code> folder of a PKGBUILD folder:</p>
<ul>
<li>
<p><code>prepare</code>: A script that is executed after the building chroot has been set up. It can be used to source
environment variables or modify other things before compilation starts.</p>
<ul>
<li>If something needs to be set up before the actual compilation process, commands can be pushed by inserting
eg. <code>$CAUR_PUSH 'source /etc/profile'</code>. Likewise, package conflicts can be solved, eg. as
follows: <code>$CAUR_PUSH 'yes | pacman -S nftables'</code> (single quotes are important because we want the variables/pipes
to
evaluate in the guest's runtime and not while interfering)</li>
</ul>
</li>
<li>
<p><code>interfere.patch</code>: a patch file that can be used to fix multiple files when many changes are
required. All changes need to be added to this file.</p>
</li>
<li>
<p><code>PKGBUILD.prepend</code>: contents of this file are added to the beginning of PKGBUILD.
This can be used to set configuration variables.</p>
</li>
<li>
<p><code>PKGBUILD.append</code>: contents of this file are added to the end of PKGBUILD.
This can be used for all kinds of fixes.
To fix <code>build()</code>, include the replacement in this file.
To add an item to an array, <code>makedepend+=(somepackage)</code>.</p>
<p>To skip build, <code>return $CI_CODE_SKIP</code>. This can be used to conditionally skip builds based on upstream check-in
results. See <code>kicad-git</code> for a GitLab example. See <code>openvino-git</code> and <code>scummvm-git</code> for GitHub examples.</p>
</li>
<li>
<p><code>on-failure.sh</code>: A script that is executed if the build fails.</p>
</li>
<li>
<p><code>on-success.sh</code>: A script that is executed if the build succeeds.</p>
</li>
</ul>
<h3 id="bumping-pkgrel"><a class="header" href="#bumping-pkgrel">Bumping pkgrel</a></h3>
<p>This is now carried out by adding the required variable <code>CI_PACKAGE_BUMP</code> to <code>.CI/config</code>. See below for more
information.</p>
<h3 id="dependency-trees"><a class="header" href="#dependency-trees">Dependency trees</a></h3>
<p>The CI builds dependency trees automatically. They are passed to the Chaotic manager as a CI artifact and read whenever
a schedule command is being executed.
No manual intervention is needed.</p>
<h3 id="ciconfig"><a class="header" href="#ciconfig">.CI/config</a></h3>
<p>The <code>.CI/config</code> file inside each package directory contains additional flags to control the pipelines and build
processes with.</p>
<ul>
<li><code>CI_MANAGE_AUR</code>: By setting this variable to <code>true</code>, the CI will update the corresponding AUR repository at the end of
a
pipeline run if changes occur (omitting CI-related files)</li>
<li><code>CI_PACKAGE_BUMP</code>: Controls package bumps for all packages which don't have <code>CI_MANAGE_AUR</code> set to <code>true</code>. The format
this needs
to follow is either <code>1:1.2.3-1/1</code> (full current version and bump count after the slash) or <code>1.2.3</code> (full current
package version,
resolves to bump count <code>1</code>).</li>
<li><code>CI_PKGBUILD_SOURCE</code>: Sets the source for all PKGBUILD-related files, used for pulling updated files from remote
repositories.
Valid values as of now are:
<ul>
<li><code>gitlab</code>: Pulls the PKGBUILD from the GitLab repository tags. It needs to follow the format <code>gitlab:$PROJECT_ID</code>.
The ID can be obtained by browsing the repository settings general section.</li>
<li><code>aur</code>: Pulls the PKGBUILD from the AUR repository, pulling in the git repo and replacing the existing files with
the
new ones.</li>
</ul>
</li>
<li><code>CI_ON_TRIGGER</code>: Can be provided in case a special schedule trigger should schedule the corresponding package. This
can be used to schedule packages daily, by setting the value to <code>daily</code>.
Since this checks whether "$TRIGGER == $CI_ON_TRIGGER", any custom schedule can be created using pipeline schedules
and setting <code>TRIGGER</code> to <code>midnight</code>, adding a fitting schedule and setting <code>CI_ON_TRIGGER</code> for any affected package
to <code>midnight</code>.
Packages having this variable set will <strong>not</strong> be scheduled via the regular on-schedule pipeline, hence this one can
also be used to prevent wasting builder resources, e.g. useful for huge <code>-git</code> packages with a lot of commit activity,
like <code>llvm-git</code>.</li>
<li><code>CI_REBUILD_TRIGGERS</code>: Add packages known to be causing rebuilds to this variable. A list of repositories to track
package versions for is provided via the repositories' <code>CI_LIB_DB</code> parameter. Each package version is hashed and
dumped to <code>.ci/lib.state</code>. Each scheduled pipeline run compares versions by checking hash mismatches and will bump
each each affected package via <code>CI_PACKAGE_BUMP</code>.</li>
<li><code>BUILDER_CACHE_SOURCES</code>: Can be set to <code>true</code> in case the sources should be cached between builds. This can be useful
in case of slow sources or sources that are not available all the time. Sources will be cleared automatically after 1
month, which is important in case packages are getting removed or the source changes.</li>
</ul>
<h3 id="known-state-variables"><a class="header" href="#known-state-variables">Known state variables</a></h3>
<p>State will be kept in the .state worktree. It can be viewed by browsing the <code>state</code> branch of a PKGBUILD repository.
Each package will have their own file named after the package name. The following variables are known to be stored:</p>
<ul>
<li><code>CI_GIT_COMMIT</code>: Used by CI to determine whether the latest commit changed. Used by <code>fetch-gitsrc</code> to schedule new
builds. Needs to be provided in case the package should be treated as a git package. CI will automatically update the
latest available commit of the git URL set in the <code>source</code> section of the PKGBUILD. If it differs, schedule a
build. -<code>CI_PKGBUILD_TIMESTAMP</code>: The last modified date of the PKGBUILD on AUR. This is used to determine whether the
PKGBUILD has changed. If it differs, schedule a build. Will be maintained automatically.</li>
</ul>
<h3 id="ci-pipeline-variables"><a class="header" href="#ci-pipeline-variables">CI pipeline variables</a></h3>
<p>These variables can be set in in the repo root's<code>.ci/config</code> to configure the pipeline behavior globally as follows:</p>
<ul>
<li><code>BUILD_REPO</code>: The target repository that will be the deploy target</li>
<li><code>GIT_AUTHOR_EMAIL</code>: The email of the user that will be used to commit</li>
<li><code>GIT_AUTHOR_NAME</code>: The name of the user that will be used to commit</li>
<li><code>REDIS_SSH_HOST</code>: The Redis SSH host for the target repository (for SSH tunneling)</li>
<li><code>REDIS_SSH_PORT</code>: The Redis SSH port for the target repository (for SSH tunneling)</li>
<li><code>REDIS_SSH_USER</code>: The Redis SSH user for the target repository (for SSH tunneling)</li>
<li><code>REDIS_PORT</code>: The redis port for the target repository (inside the SSH tunnel)</li>
<li><code>REPO_NAME</code>: The name that this repository is referred to in Chaotic Manager's config</li>
<li><code>CI_HUMAN_REVIEW</code>: If merge/pull requests should be created for non pkgver changes</li>
<li><code>CI_MANAGE_AUR</code>: This should be set to true in case select AUR repositories should be managed by CI</li>
<li><code>CI_OVERWRITE_COMMITS</code>: If we should overwrite existing automated commits to reduce the size of the git history</li>
<li><code>CI_CLONE_DELAY</code>: How long to wait between every executed git clone command for rate limits</li>
<li><code>CI_AUR_PROXY</code>: Proxy to use for AUR requests</li>
</ul>
<h3 id="managing-aur-packages"><a class="header" href="#managing-aur-packages">Managing AUR packages</a></h3>
<p>AUR packages can also be managed via this repository in an automated way using <code>.CI_CONFIG</code>.
This means that after each scheduled and on-commit pipeline, the AUR repository will be updated to reflect the changes
done to the PKGBUILD folder's files.
Files not relevant to AUR maintenance (e.g. <code>.CI</code> folders) will be omitted.
The commit message reflects the fact that the commit was created by a CI pipeline
and contains the link to the source repository's commit history and the pipeline run which triggered the update commit.</p>
<h3 id="updating-the-cis-scripts"><a class="header" href="#updating-the-cis-scripts">Updating the CI's scripts</a></h3>
<p>This is done automatically via the CI pipeline. Once changes have been detected on the template repository, all files
will be updated to the current version.</p>
<h3 id="issues-and-pipeline-failures"><a class="header" href="#issues-and-pipeline-failures">Issues and pipeline failures</a></h3>
<h4 id="last-on-commit-pipeline-failed"><a class="header" href="#last-on-commit-pipeline-failed">Last on-commit pipeline failed</a></h4>
<p>This can happen in case of a few reasons, for example having provided an invalid package name. This causes
the <code>scheduled</code> tag to not be updated.
In this case, the on-schedule pipeline will not be able to run.
The last on-commit pipeline needs to be fixed before the on-schedule pipeline can run again.
Build failures however are not accounted as the <code>scheduled</code> tag would be updated already as soon as the scheduling
parameters were generated.
Force pushing a fixed up commit is actively encouraged in such a case, as pushing another commit will cause the CI to
evaluate the previous commits it missed, leading to noticing the same issue again and bailing out instead of silently
continuing.
This has been a design decision to prevent failures from being overlooked.</p>
<h4 id="resetting-the-build-queue"><a class="header" href="#resetting-the-build-queue">Resetting the build queue</a></h4>
<p>There might be rare cases in which a reset of the build queue is needed. This can be done by shutting down the central
Redis instance, removing its dump, and restarting its service.</p>
<h3 id="deploying-to-different-repos-using-the-same-infrastructure"><a class="header" href="#deploying-to-different-repos-using-the-same-infrastructure">Deploying to different repos using the same infrastructure</a></h3>
<p>This is now an officially supported use case. The only thing required is to use another repository that is going to
store PKGBUILDs and execute CI pipelines.
The environment variables passed to the main Chaotic Manager instance control which repositories are available to use
while scheduling packages. See below for more information.</p>
<h2 id="chaotic-manager"><a class="header" href="#chaotic-manager">Chaotic Manager</a></h2>
<p>This tool is distributed as Docker containers and consists of a pair of manager and builder instances.</p>
<ul>
<li>Manager: <code>registry.gitlab.com/garuda-linux/tools/chaotic-manager/manager</code>
<ul>
<li>Manages builds by adding them to the schedule, used e.g. in the schedule step of CI pipelines</li>
<li>Provides log management and the live-updating logs</li>
<li>Manages any existing builds by spinning up build containers, picking from the available BullMQ builder / database
queues</li>
<li>Picks up already built package archives from the landing zone (builder containers push finished build archives
here)
to add them to the database of the target repository</li>
</ul>
</li>
<li>Builder: <code>registry.gitlab.com/garuda-linux/tools/chaotic-manager/builder</code>
<ul>
<li>This one contains the actual logic behind package builds (
seen <a href="https://gitlab.com/garuda-linux/tools/chaotic-manager/-/tree/main/builder-container?ref_type=heads">here</a>)
known from infra 3.0 like <code>interfere.sh</code>, <code>database.sh</code> etc.</li>
<li>This one is used by an executing manager instance to run the build processes with. It runs jobs present in the
builder BullMQ queue.</li>
</ul>
</li>
</ul>
<p>An example of a valid config can be found in
the <a href="https://gitlab.com/garuda-linux/infra-nix/-/blob/main/docker-compose/chaotic-v4/docker-compose.yml?ref_type=heads#L38">Garuda Linux infrastructure repository</a>.
The following variables can be set in Docker environment:</p>
<ul>
<li><code>DATABASE_HOST</code>: database address published to the outside world</li>
<li><code>DATABASE_PORT</code>: the port behind packages can be deployed to</li>
<li><code>DATABASE_USER</code>: the user to use to deploy packages</li>
<li><code>GPG_PATH</code>: where the <code>.gnupg</code> folder resides (holding the key for signing packages)</li>
<li><code>LANDING_ZONE_PATH</code>: where the landing zone is (here packages get deployed and later picked up by the database job
before getting into the final repository)</li>
<li><code>LOGS_URL</code>: the URL that serves the logfiles (we get sent here when clicking CI's external stages)</li>
<li><code>PACKAGE_REPOS_NOTIFIERS</code>: needed configs to provide external CI stages for GitLab CI/GitHub Actions</li>
<li><code>PACKAGE_REPOS</code>: the source repositories containing PKGBUILD folders</li>
<li><code>PACKAGE_TARGET_REPOS</code>: the repository a package is getting deployed to (including its URL and extra keyrings/repos
needed)</li>
<li><code>REDIS_PASSWORD</code>: password for accessing the Redis instance</li>
<li><code>REDIS_SSH_HOST</code>: where to access the Redis instance</li>
<li><code>REDIS_SSH_USER</code>: the user who can access the Redis instance</li>
<li><code>REPO_PATH</code>: the path where the final package deployment happens</li>
<li><code>TELEGRAM_BOT_TOKEN</code>: the token for the Telegram bot, used for notifications</li>
<li><code>TELEGRAM_CHAT_ID</code>: the chat ID for the Telegram bot to send deployment or failure notifications to</li>
</ul>
<p>The following variables are only relevant for builder instances:</p>
<ul>
<li><code>BUILDER_HOSTNAME</code>: the hostname of the builder will be displayed in package logs to determine which builder built a
package</li>
<li><code>BUILDER_TIMEOUT</code>: the timeout for a package build, 3600 seconds by default. Should be increased on slow builders</li>
</ul>
<h3 id="setting-up"><a class="header" href="#setting-up">Setting up</a></h3>
<h4 id="requirements"><a class="header" href="#requirements">Requirements</a></h4>
<p>The base requirements for running this kind of setup are as follows:</p>
<ul>
<li>
<p>Docker/Podman must be installed in the target system, docker-/podman-compose are good to have as well. We will use it
in our following examples.</p>
</li>
<li>
<p>A Redis instance must be available, e.g. installed on the host system or added to ´docker-compose.yml`:</p>
<pre><code class="language-yml">chaotic-redis:
  image: redis:alpine
  container_name: chaotic-redis
  restart: always
  ports:
    - "6379:6379"
  command: redis-server --save 60 1 --loglevel warning --requirepass verysecurepassword
  volumes:
    - ./redis-data:/data
</code></pre>
<p>The following examples assume Redis to be installed on the host system. In case it is added to <code>docker-compose.yml</code>,
replace any occurances of <code>host.docker.internal</code> with <code>chaotic-redis</code>.</p>
</li>
<li>
<p>A reverse proxy like Nginx to expose the Chaotic Manager's logs to the public in a secure way should be available.
E.g., using Nginx it is sufficient to <code>proxy_pass</code> the specified <code>--web-port</code> value to the Manager instance container.
Additionally, the following settings might be usedful:</p>
<pre><code class="language-ǹginx">proxy_buffering off;
proxy_read_timeout 330s;
</code></pre>
</li>
</ul>
<h4 id="repository-setup"><a class="header" href="#repository-setup">Repository setup</a></h4>
<p>The repository needs to be derived from
the <a href="https://github.com/chaotic-cx/chaotic-repository-template">repository template</a>. On GitHub,
the <a href="https://github.com/new?template_name=chaotic-repository-template&amp;template_owner=chaotic-cx">"Use this template"</a>
feature may be used.
Afterward, customize the <code>.ci/config</code> file according to your needs. This file contains global configuration for pipeline
runs and CI behaviour.
The following options exist as of today:</p>
<ul>
<li><code>BUILD_REPO</code>: The target repository that will be the deploy target</li>
<li><code>GIT_AUTHOR_EMAIL</code>: The email of the user that will be used to commit</li>
<li><code>GIT_AUTHOR_NAME</code>: The name of the user that will be used to commit</li>
<li><code>REDIS_SSH_HOST</code>: The redis host for the target repository</li>
<li><code>REDIS_SSH_PORT</code>: The redis port for the target repository</li>
<li><code>REDIS_SSH_USER</code>: The redis user for the target repository</li>
<li><code>REDIS_PORT</code>: The redis port for the target repository</li>
<li><code>REPO_NAME</code>: The name that this repository is referred to in chaotic-manager's config</li>
<li><code>CI_HUMAN_REVIEW</code>: Whether merge/pull requests should be created for non pkgver changes (false/true)</li>
<li><code>CI_MANAGE_AUR</code>: This should be set to true in case select AUR repositories should be managed by CI. A fitting SSH key
needs to be deployed as AUR_KEY via secret CI variable.</li>
<li><code>CI_OVERWRITE_COMMITS</code>: Whether we should overwrite existing automated commits to reduce the size of the git history (
false/true)</li>
<li><code>CI_CLONE_DELAY</code>: How long to wait between every executed git clone command for ratelimits (false/true)</li>
<li><code>CI_AUR_PROXY</code>: Proxy to use for AUR requests</li>
<li><code>CI_LIB_DB</code>: Archlinux / Chaotic-AUR repo mirror to use for pulling db files from, in the following
format: <code>https://arch.mirror.constant.com/core/os/x86_64/core.db https://arch.mirror.constant.com/community/os/x86_64/community.db ...</code></li>
</ul>
<h4 id="exemplary-manager-instance-setup"><a class="header" href="#exemplary-manager-instance-setup">Exemplary manager instance setup</a></h4>
<pre><code class="language-yaml">chaotic-manager:
  image: registry.gitlab.com/garuda-linux/tools/chaotic-manager/manager:latest
  container_name: chaotic-manager
  command: database --web-port 8080
  environment:
    DATABASE_HOST: sub.domain.tld
    DATABASE_PORT: 22
    DATABASE_USER: package-deployer
    GPG_PATH: /var/awesome-repo/gnupg
    LANDING_ZONE_PATH: /var/awesome-repo/landing-zone
    LOGS_URL: https://sub.domain.tld/logs/logs.html
    REDIS_PASSWORD: verysecurepassword
    REDIS_SSH_HOST: host.docker.internal
    REDIS_SSH_USER: package-deployer
    REPO_PATH: /srv/http/repos
    TELEGRAM_BOT_TOKEN: 1234567890
    TELEGRAM_CHAT_ID: 0987654321
    PACKAGE_REPOS: &gt;-
      {
          "awesome-repo": {
              "url": "https://gitlab.com/awesome-repo/pkgbuilds"
          }
      }
    PACKAGE_TARGET_REPOS: &gt;-
      {
          "awesome-repo": {
              "extra_repos": [
                  {
                      "name": "awesome-repo",
                      "servers": [
                          "https://sub.domain.tld/awesome-repo/x86_64"
                      ]
                  }
              ],
              "extra_keyrings": [
                  "https://sub.domain.tld/awesome-repo/awesome-keyring.pkg.tar.zst"
              ]
          }
      }
    PACKAGE_REPOS_NOTIFIERS: &gt;-
      {
          "awesome-repo": {
              "id": "123456",
              "token": "GITLABAPITOKENWITHAPIACCESS",
              "check_name": "awesome-repo: %pkgbase%"
          }
      }
  volumes:
    - ./sshkey:/app/sshkey
    - /var/run/docker.sock:/var/run/docker.sock
    - /srv/http/repos:/repo_root
  extra_hosts:
    - "host.docker.internal:host-gateway"
  ports: [8080:8080]
</code></pre>
<p>The following things are to note:</p>
<ul>
<li><code>PACKAGE_REPOS</code>, <code>PACKAGE_TARGET_REPOS</code> and <code>PACKAGE_REPOS_NOTIFIERS</code> are JSON values and need to be valid JSON in
order to be processed.</li>
<li>The above setup assumes the docker-compose.yml to be present in <code>var/awesome-repo</code>.</li>
<li><code>LOGS_URL</code> needs to match the address which the reverse proxy publishes <code>--web-port 8080</code> to the outside world.</li>
<li><code>REPO_PATH</code> is the path of the repository <em>on the Docker host</em>. The same path must be mapped to <code>/repo_root</code> inside
the container via volumes.</li>
<li><code>/app/sshkey</code> is assumed to be the private SSH key</li>
<li>Ports don't have to explicitly exposed if using an Nginx Docker container, in this setup however, our Nginx and Redis
instance are present on the host system.</li>
<li><code>PACKAGE_REPOS_NOTIFIERS</code> and <code>TELEGRAM_*</code> variables are optional but provide additional functionality of they are
set.</li>
<li><code>DATABASE_HOST</code> refers to the address published to the outside world, e.g. for additional builders an other servers.</li>
</ul>
<h4 id="examplary-builder-instance-setup"><a class="header" href="#examplary-builder-instance-setup">Examplary builder instance setup</a></h4>
<pre><code class="language-yaml">---
services:
  chaotic-builder:
    image: registry.gitlab.com/garuda-linux/tools/chaotic-manager/manager:latest
    container_name: chaotic-builder
    command: builder
    environment:
      BUILDER_TIMEOUT: 7200
      BUILDER_HOSTNAME: awesome-builder
      REDIS_PASSWORD: verysecurepassword
      REDIS_SSH_HOST: host.docker.internal
      REDIS_SSH_USER: package-deployer
      SHARED_PATH: /var/chaotic/shared
      DATABASE_HOST: host.docker.internal
      DATABASE_PORT: 22
    volumes:
      - ./shared:/shared
      - ./sshkey:/app/sshkey
      - /var/run/docker.sock:/var/run/docker.sock
    extra_hosts:
      - "host.docker.internal:host-gateway"
</code></pre>
<p>The following things are to note:</p>
<ul>
<li>The above setup assumes the docker-compose.yml to be present in <code>var/awesome-repo</code>.</li>
<li>The <code>SHARED_PATH</code> variable needs to match the directory mapped to <code>/shared</code> inside the container.</li>
<li><code>DATABASE_HOST</code> can in theory be any other host, but can be set to <code>host.docker.internal</code> in case the Redis instance
runs on the Docker host.</li>
<li>The Docker socket needs to be mounted as the builder instance will use it to spin up build container instances.</li>
<li><code>/app/sshkey</code> is assumed to be the private SSH key used for pushing finished package builds to the manager instance's
landing zone.</li>
<li><code>BUILDER_TIMEOUT</code> only needs to be set in case it is a slower build machine which does not finish heaver tasks in one
hour.</li>
<li>As many instances of this container can be added the setup as wanted. Each of them will allow processing another build
at the same time in total.</li>
</ul>
<h3 id="features"><a class="header" href="#features">Features</a></h3>
<h4 id="chaotic-manager-container-commands"><a class="header" href="#chaotic-manager-container-commands">Chaotic-Manager container commands</a></h4>
<ul>
<li><code>schedule</code>: Schedules a new package build by adding it to the Redis instance. It takes the following arguments:
<ul>
<li><code>arch</code>: The architecture to build the package for</li>
<li><code>target-repo</code>: The target repository to deploy the package to, referring to the <code>PACKAGE_TARGET_REPOS</code> variable
set
in the Docker environment variables.</li>
<li><code>source-repo</code>: The source repository to pull the package from, referring to the <code>PACKAGE_REPOS</code> variable set in
the
Docker environment variables.</li>
<li><code>commit</code>: The commit hash which the schedule call originates from</li>
<li><code>deptree</code>: the dependency tree built by the CI pipeline. This parameter is omitted in CI pipelines and instead
passed as file, reading from <code>/.ci/deptree.txt</code>. The reason is that the parameter will be to huge to be processed
by
the shell if 100+ packages are
scheduled at the same time.
It contains information about the build order of packages and their dependencies.</li>
</ul>
</li>
<li><code>builder</code>: Starts the build job, which then grabs any available build jobs from the build queue.</li>
<li><code>auto-repo-remove</code>: Removes obsolete packages from the target repository. Further parameters must include the pkgbases
to be removed.</li>
<li><code>database</code>: Starts the manager instance, which is responsible for managing queues, logs and database jobs. It
additionally spins up a web server to serve logs from if <code>--web-port</code> is passed as argument.</li>
<li><code>web</code>: Starts the web server to serve logs from. This is only needed in case the manager instance does not run the web
server.</li>
</ul>
<h4 id="web-server"><a class="header" href="#web-server">Web server</a></h4>
<p>Available routes on the port set up be the <code>--web-port</code> parameter are as follows:</p>
<ul>
<li><code>/api/logs/:id/:timestamp</code>: Returns the log file of a package build. The <code>id</code> is the package's ID, the <code>timestamp</code> is
the timestamp of the build.</li>
<li><code>/api/logs/:id</code>: Returns the latest log file of a package build. The <code>id</code> is the package's ID.</li>
<li><code>/api/queue/stats</code>: Returns a JSON object containing the current queue stats.</li>
<li><code>/api/queue/packages</code>: Returns a JSON object containing information the currently scheduled packages.</li>
<li><code>/metrics</code>: Returns collected Prometheus metrics.</li>
</ul>
<h4 id="notifications"><a class="header" href="#notifications">Notifications</a></h4>
<p>Notifications about relevant events can be sent to a Telegram channel or chat via a Bot.
This requires a valid Bot token and the Chat ID to be set.
The following events are currently supported:</p>
<ul>
<li>
<p>Build failures: additionally contains links to full build logs and the originating commit.</p>
<pre><code class="language-text">🚨 Failed deploying to awesome-repo:
&gt; freecad-git - logs- commit
</code></pre>
</li>
<li>
<p>Build success:</p>
<pre><code class="language-text">📣 New deployment to awesome-repo:
&gt; freecad-git
</code></pre>
</li>
<li>
<p>Timed out build: Contains links to full build logs and the originating commit.</p>
<pre><code class="language-text">⏳ Build for awesome-repo failed due to a timeout:
&gt; freecad-git - logs - commit
</code></pre>
</li>
<li>
<p>Successful repo-remove jobs:</p>
<pre><code class="language-text">✅ Repo-remove job for awesome-repo finished successfully
</code></pre>
</li>
<li>
<p>Failed repo-remove jobs:</p>
<pre><code class="language-text">🚫 Repo-remove job for awesome-repo failed
</code></pre>
</li>
</ul>
<h4 id="build-order"><a class="header" href="#build-order">Build order</a></h4>
<p>The build order is determined by the dependency tree built by the CI pipeline.
This tree is passed to the manager and is then used to determine the correct build order automatically.
No further intervention is needed to achieve this.</p>
<h4 id="live-updating-logs"><a class="header" href="#live-updating-logs">Live-updating logs</a></h4>
<p>Logs are live-updating and can be viewed in real-time via the web server.
In case GitLab is used and <code>PACKAGE_REPOS_NOTIFIERS</code> is set,
an external CI stage will be created for every package scheduled during the CI run, linking to the log.</p>
<h4 id="prometheus-metrics"><a class="header" href="#prometheus-metrics">Prometheus metrics</a></h4>
<p>Prometheus metrics are available at the <code>/metrics</code> endpoint of the web server.
Currently, we collect default <code>prom-client</code> metrics as well as statistics about total event count of each build status
(failed, successful, already-built, timed out) as well as metrics about overall build times.
These can be collected via a Prometheus instance and then be visualized using Grafana.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../repositories/pkgbuilds.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../services/discourse.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../repositories/pkgbuilds.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../services/discourse.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>

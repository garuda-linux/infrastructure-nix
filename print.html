<!DOCTYPE HTML>
<html lang="en" class="mocha" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Garuda&#x27;s infra documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="Contains the documentation for the Garuda Linux infrastructure.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./mdbook-admonish.css">
        <link rel="stylesheet" href="theme/css/custom.css">
        <link rel="stylesheet" href="./theme/catppuccin.css">
        <link rel="stylesheet" href="./theme/catppuccin-admonish.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "mocha" : "mocha";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('mocha')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">Welcome</li><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="general.html"><strong aria-hidden="true">2.</strong> General information</a></li><li class="chapter-item expanded "><a href="common.html"><strong aria-hidden="true">3.</strong> Common tasks</a></li><li class="chapter-item expanded "><a href="important-links.html"><strong aria-hidden="true">4.</strong> Important links</a></li><li class="chapter-item expanded affix "><li class="part-title">Users</li><li class="chapter-item expanded "><a href="users.html"><strong aria-hidden="true">5.</strong> Users</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="users/current_users.html"><strong aria-hidden="true">5.1.</strong> Current users</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Hosts</li><li class="chapter-item expanded "><a href="hosts/immortalis.html"><strong aria-hidden="true">6.</strong> immortalis</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="nixos-containers/docker.html"><strong aria-hidden="true">6.1.</strong> docker</a></li><li class="chapter-item expanded "><a href="nixos-containers/docker-proxied.html"><strong aria-hidden="true">6.2.</strong> docker-proxied</a></li><li class="chapter-item expanded "><a href="nixos-containers/forum.html"><strong aria-hidden="true">6.3.</strong> forum</a></li><li class="chapter-item expanded "><a href="nixos-containers/github-runner.html"><strong aria-hidden="true">6.4.</strong> github-runner</a></li><li class="chapter-item expanded "><a href="nixos-containers/lemmy.html"><strong aria-hidden="true">6.5.</strong> lemmy</a></li><li class="chapter-item expanded "><a href="nixos-containers/mastodon.html"><strong aria-hidden="true">6.6.</strong> mastodon</a></li><li class="chapter-item expanded "><a href="nixos-containers/mongodb.html"><strong aria-hidden="true">6.7.</strong> mongodb</a></li><li class="chapter-item expanded "><a href="nixos-containers/postgres.html"><strong aria-hidden="true">6.8.</strong> postgres</a></li><li class="chapter-item expanded "><a href="nixos-containers/temeraire.html"><strong aria-hidden="true">6.9.</strong> temeraire</a></li><li class="chapter-item expanded "><a href="nixos-containers/web-front.html"><strong aria-hidden="true">6.10.</strong> web-front</a></li></ol></li><li class="chapter-item expanded "><a href="hosts/garuda-build.html"><strong aria-hidden="true">7.</strong> garuda-build</a></li><li class="chapter-item expanded "><a href="hosts/garuda-mail.html"><strong aria-hidden="true">8.</strong> garuda-mail</a></li><li class="chapter-item expanded affix "><li class="part-title">Repository infrastructure</li><li class="chapter-item expanded "><a href="repositories/general.html"><strong aria-hidden="true">9.</strong> General information</a></li><li class="chapter-item expanded "><a href="repositories/pkgbuilds.html"><strong aria-hidden="true">10.</strong> PKGBUILDs</a></li><li class="chapter-item expanded affix "><li class="part-title">Services</li><li class="chapter-item expanded "><a href="services/chaotic-4.0.html"><strong aria-hidden="true">11.</strong> Chaotic 4.0</a></li><li class="chapter-item expanded "><a href="services/discourse.html"><strong aria-hidden="true">12.</strong> Discourse</a></li><li class="chapter-item expanded "><a href="websites/documentation.html"><strong aria-hidden="true">13.</strong> Documentation</a></li><li class="chapter-item expanded "><a href="services/tailscale.html"><strong aria-hidden="true">14.</strong> Tailscale</a></li><li class="chapter-item expanded affix "><li class="part-title">Misc</li><li class="chapter-item expanded "><a href="code-of-conduct.html"><strong aria-hidden="true">15.</strong> Code of Conduct</a></li><li class="chapter-item expanded "><a href="privacy-policy.html"><strong aria-hidden="true">16.</strong> Privacy policy</a></li><li class="chapter-item expanded "><a href="security.html"><strong aria-hidden="true">17.</strong> Security</a></li><li class="chapter-item expanded "><a href="credits.html"><strong aria-hidden="true">18.</strong> Credits</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="latte">Latte</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="frappe">Frappé</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="macchiato">Macchiato</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mocha">Mocha</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Garuda&#x27;s infra documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/garuda-linux/infrastructure-nix" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-code-fork"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="garuda-linux-server-configurations"><a class="header" href="#garuda-linux-server-configurations">Garuda Linux server configurations</a></h1>
<p><a href="https://builtwithnix.org"><img src="https://img.shields.io/static/v1?logo=nixos&amp;logoColor=white&amp;label=&amp;message=Built%20with%20Nix&amp;color=41439a" alt="built with nix" /></a> <a href="https://github.com/garuda-linux/infrastructure-nix/actions/workflows/pages.yml"><img src="https://github.com/garuda-linux/infrastructure-nix/actions/workflows/pages.yml/badge.svg" alt="deploy docs" /></a></p>
<h2 id="general-information"><a class="header" href="#general-information">General information</a></h2>
<ul>
<li>Our current infrastructure is hosted in one of <a href="https://www.hetzner.com/dedicated-rootserver/ax102">these</a>.</li>
<li>The only other server not being contained in this dedicated server is our mail server.</li>
<li>Both servers are being backed up to Hetzner storage boxes via <a href="https://www.borgbackup.org/">Borg</a>.</li>
<li>After multiple different setups, we settled on <a href="https://nixos.org/">NixOS</a> as our main OS as it provides reproducible and atomically updated system states</li>
<li>Most (sub)domains are protected by Cloudflare while also making use of its caching feature.
Exemptions are services such as our mail server and parts violating Cloudflares rules such as proxying Piped content.</li>
</ul>
<h2 id="quick-links"><a class="header" href="#quick-links">Quick links</a></h2>
<ul>
<li><a href="https://docs.garudalinux.net/common">Common maintenance tasks</a></li>
<li><a href="https://docs.garudalinux.net/hosts/garuda-mail">Host: garuda-mail</a></li>
<li><a href="https://docs.garudalinux.net/hosts/immortalis">Host: immortalis</a></li>
</ul>
<h2 id="devshell-and-how-to-enter-it"><a class="header" href="#devshell-and-how-to-enter-it">Devshell and how to enter it</a></h2>
<p>This NixOS flake provides a <a href="https://github.com/numtide/devshell">devshell</a> which contains all deployment tools as well as handy aliases for common tasks.
The only requirement for using it is having the Nix package manager available. It can be installed on various distributions via the package manager or the following script (<a href="https://zero-to-nix.com/start/install">click me for more information</a>):</p>
<pre><code class="language-shell">curl --proto '=https' --tlsv1.2 -sSf -L https://install.determinate.systems/nix -o nix-install.sh # Check its content afterwards
sh ./nix-install.sh install --diagnostic-endpoint=""
</code></pre>
<p>This installs the Nix packages with flakes already pre-enabled. After that, the shell can be invoked as follows:</p>
<pre><code class="language-shell">nix develop # The intended way to use the devshell
nix-shell # Legacy, non-flakes way if flakes are not available for some reason
</code></pre>
<p>This also sets up pre-commit-hooks and shows the currently implemented tasks, which can be executed by running the command.</p>
<pre><code class="language-shell">[infra-nix]

ansible-core    - Radically simple IT automation
apply           - Applies the infra-nix configuration previously deployed to the servers
buildiso-local  - Spawns a local buildiso shell to build to ./buildiso (needs Docker)
buildiso-remote - Spawns a buildiso shell on the iso-runner builder
clean           - Runs the garbage collection on the servers
deploy          - Deploys the local NixOS configuration to the servers
update          - Performs a full system update on the servers by bumping flake lock
update-forum    - Updates the Discourse container of our forum
update-toolbox  - Updates the locked Chaotic toolbox commit and deploys the changes
update-website  - Updates the locked website commit and deploys the changes
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="general-structure"><a class="header" href="#general-structure">General structure</a></h1>
<p>A general overview of the folder structure can be found below:</p>
<pre><code class="language-shell">├── assets
├── docs
│  ├── src
│  │  ├── hosts
│  │  ├── nixos-containers
│  │  ├── repositories
│  │  ├── services
│  │  ├── users
│  │  └── websites
│  └── theme
│     ├── css
│     └── fonts
├── home-manager
├── host_vars
│  ├── garuda-build
│  ├── garuda-mail
│  └── immortalis
├── nixos
│  ├── hosts
│  │  ├── chaotic-v4
│  │  ├── docker
│  │  │  └── configs
│  │  ├── docker-proxied
│  │  ├── garuda-build
│  │  ├── garuda-mail
│  │  ├── github-runner
│  │  └── immortalis
│  ├── modules
│  │  └── static
│  └── services
│     ├── chaotic
│     ├── docker-compose-runner
│     └── monitoring
├── playbooks
├── scripts
└── secrets
</code></pre>
<h2 id="secrets-in-this-repository"><a class="header" href="#secrets-in-this-repository">Secrets in this repository</a></h2>
<p>Secrets are managed via a custom Git submodule that contains <code>ansible-vault</code> encrypted files as well as a custom NixOS module <code>garuda-lib</code> which makes them available to our services.
The submodule is available in the <code>secrets</code> directory once it has been set up for the first time. It can be initialized by running:</p>
<pre><code class="language-sh">git submodule init
git submodule update
</code></pre>
<p>To view or edit any of these files, one can use the following commands:</p>
<pre><code class="language-sh">ansible-vault decrypt secrets/pathtofile
ansible-vault edit secrets/pathtofile
ansible-vault encrypt secrets/pathtofile
</code></pre>
<p>Further information on <code>ansible-vault</code> can be found in its <a href="https://docs.ansible.com/ansible/latest/vault_guide/index.html">documentation</a>.
It is important to keep the <code>secrets</code> directory in the latest state before deploying a new configuration as misconfigurations might happen otherwise.</p>
<h2 id="passwords-in-general"><a class="header" href="#passwords-in-general">Passwords in general</a></h2>
<p>Our mission-critical passwords that maintainers and team members need to have access to are stored in our <a href="vault.garudalinux.org">Bitwarden instance</a>.
After creating an account, maintainers need to be invited to the Garuda Linux organisation in order to access the stored credentials.</p>
<h2 id="linting-and-formatting"><a class="header" href="#linting-and-formatting">Linting and formatting</a></h2>
<p>We utilize <a href="https://github.com/cachix/pre-commit-hooks.nix">pre-commit-hooks</a> to automatically set up the pre-commit-hook with all the tools once <code>nix-shell</code> or <code>nix develop</code> is run for the first time.
Checks can then be executed by running one of the following configs:</p>
<pre><code class="language-sh">nix flake check # checks flake outputs and runs pre-commit at the end
pre-commit run --all-files # only runs the pre-commit tools on all files
</code></pre>
<p>Its configuration can be found in the <code>flake.nix</code> file. (<a href="https://gitlab.com/garuda-linux/infra-nix/-/blob/main/flake.nix">click me</a>). At the time of writing, the following tools are being run:</p>
<ul>
<li><a href="https://github.com/rhysd/actionlint">actionlint</a></li>
<li><a href="https://github.com/ansible/ansible-lint">ansible-lint</a></li>
<li><a href="https://github.com/commitizen-tools/commitizen">commitizen</a></li>
<li><a href="https://github.com/astro/deadnix">deadnix</a></li>
<li><a href="https://github.com/oxalica/nil">nil</a></li>
<li><a href="https://github.com/nix-community/nixpkgs-fmt">nixpkgs-fmt</a></li>
<li><a href="https://prettier.io/">prettier</a></li>
<li><a href="https://github.com/nerdypepper/statix">statix</a></li>
<li><a href="https://github.com/adrienverge/yamllint">yamllint</a></li>
</ul>
<p>It is recommended to run <code>pre-commit run --all-files</code> before trying to commit changes. Then use <code>cz commit</code> to generate a <code>commitizen</code> complying commit message.</p>
<h2 id="cicd"><a class="header" href="#cicd">CI/CD</a></h2>
<p>We have used pull-/push-based mirroring for this git repository, which allows easy access to Renovate without having to run a custom instance of it. The following tasks have been implemented as of now:</p>
<ul>
<li><code>nix flake check</code> runs for every labeled PR and commit on main.</li>
<li><a href="https://renovatebot.com/">Renovate</a> periodically checks <code>docker-compose.yml</code> and other supported files for version updates. It has a <a href="https://github.com/garuda-linux/infrastructure-nix/issues/5">dependency dashboard</a> as well as the <a href="https://developer.mend.io/github/garuda-linux/infrastructure-nix">developer interface</a> to check logs of individual runs. Minor updates appear as grouped PRs while major updates are separated from those. Note that this only applies to the GitHub side.</li>
<li>Deployment of our <a href="https://github.com/rust-lang/mdBook">mdBook-based</a> documentation to Cloudflare pages.</li>
<li>Deployment of our Website to Cloudflare pages.</li>
</ul>
<p>Workflows will generally only be executed if a relevant file has been changed, eg. <code>nix flake check</code> won't run if only the README was changed.</p>
<h2 id="monitoring"><a class="header" href="#monitoring">Monitoring</a></h2>
<p>Our current monitoring stack mostly relies on Netdata to provide insight into current system loads and trends.
The major reason for using it was that it provides the most vital metrics and alerts out of the box without having to create in-depth configurations.
Might switch to the Prometheus/Grafana/Loki stack in the future. We used to set up children -&gt; parent streaming in the past, though after transitioning to one big host this didn't make sense anymore.
Instead, up to 10GB of data gets stored on individual hosts.
While Netdata agents do have their dashboard, the <a href="https://app.netdata.cloud/spaces/garuda-infra/rooms/all-nodes">Dashboard provided by Netdata</a> is far superior and allows a better insight, eg. by offering the functions feature.
Additional services like Squid or Nginx have been configured to be monitored by Netdata plugins as well. Further information can be found in its <a href="https://learn.netdata.cloud/">documentation</a>.
To access the previously linked dashboard, use <code>team@garudalinux.org</code> as login, the login will be completed after opening the link sent here.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="common-maintenance-tasks"><a class="header" href="#common-maintenance-tasks">Common maintenance tasks</a></h2>
<h3 id="rebuilding--updating-the-forum-container"><a class="header" href="#rebuilding--updating-the-forum-container">Rebuilding / updating the forum container</a></h3>
<p>Sometimes Discourse needs its container to build rebuild via cli rather than the webinterface. This can be done with:</p>
<pre><code class="language-sh">ssh -p 224 $user@116.202.208.112
cd /var/discourse
sudo ./launcher rebuild app
</code></pre>
<h3 id="building-iso-files"><a class="header" href="#building-iso-files">Building ISO files</a></h3>
<p>To build Garuda ISO, one needs to connect to the <code>iso-runner</code> container and execute the <code>buildiso</code> command, which opens
a shell containing the needed environment:</p>
<pre><code class="language-sh">ssh -p 227 $user@116.202.208.112 # if one ran nix develop before, this can be skipped
buildiso
buildiso -i # updates the iso-profiles repo
buildiso -p dr460nized
</code></pre>
<p>Further information on available commands can be found in
the <a href="https://gitlab.com/garuda-linux/tools/garuda-tools">garuda-tools</a> repository.
After the build process is finished, builds can be found
on <a href="https://iso.builds.garudalinux.org/iso/garuda/">iso.builds.garudalinux.org</a>.
No automatic pushing to Sourceforge and Cloudflare R2 happens by default, see below for more information on how to
achieve this.</p>
<h3 id="deploying-a-new-iso-release"><a class="header" href="#deploying-a-new-iso-release">Deploying a new ISO release</a></h3>
<p>We are assuming all ISOs have been tested for functionality before executing any of those commands.</p>
<pre><code class="language-sh">ssh -p 227 $user@116.202.208.112
buildall # builds all ISO provided in the buildall command
deployiso -FS # sync to Cloudflare R2 and Sourceforge
deployiso -FSR # sync to Cloudflare R2 and Sourceforge while also updating the latest (stable, non-nightly) release
deployiso -Sd # to delete the old ISOs on Sourceforge once they aren't needed anymore
deployiso -FSRd # oneliner for the above-given commands
</code></pre>
<h3 id="updating-the-system"><a class="header" href="#updating-the-system">Updating the system</a></h3>
<p>One needs to have the <a href="https://gitlab.com/garuda-linux/infra-nix">infra-nix</a> repo cloned locally. Then proceed by
updating the <code>flake.lock</code> file, pushing it to the server &amp; building the configurations:</p>
<pre><code class="language-sh">nix flake update
ansible-playbook garuda.yml -l $servername # Eg. immortalis for the Hetzner host
deploy # Skip using the above command and use this one in case nix develop was used
</code></pre>
<p>Then you can either apply it via Ansible or connect to the host to view more details about the process while it runs:</p>
<pre><code class="language-sh">ansible-playbook apply.yml -l $servername # Ansible

apply # Nix develop shell

ssh -p 666 $user@116.202.208.112 # Manually, exemplary on immortalis
sudo nixos-rebuild switch
</code></pre>
<p>Keep in mind that this will restart every service whose files changed since the last system update. On our Hetzner
server, this includes a restart of every declarative <code>nixos-container</code> if needed, causing a small downtime.</p>
<h3 id="changing-system-configurations"><a class="header" href="#changing-system-configurations">Changing system configurations</a></h3>
<p>Most system configurations are contained in individual Nix files in the <code>nix</code> directory of this repo. This means
changing anything must not be done manually but by editing the corresponding file and pushing/applying the configuration
afterward.</p>
<pre><code class="language-sh">ansible-playbook garuda.yml -l $servername # Eg. immortalis for the Hetzner host
deploy # In case nix develop is used
</code></pre>
<p>As with the system update, one can either apply via Ansible or manually:</p>
<pre><code class="language-sh">ansible-playbook apply.yml -l $servername # Ansible

apply # Nix develop shell

ssh -p 666 $user@116.202.208.112 # Manually, exemplary on immortalis
sudo nixos-rebuild switch
</code></pre>
<h4 id="adding-a-user"><a class="header" href="#adding-a-user">Adding a user</a></h4>
<p>Adding users needs to be done in <code>users.nix</code>:</p>
<ul>
<li>Add a new
user <a href="https://gitlab.com/garuda-linux/infra-nix/-/blob/main/nixos/modules/users.nix?ref_type=heads#L14">here</a></li>
<li>Add the SSH public key
to <a href="https://gitlab.com/garuda-linux/infra-nix/-/blob/main/flake.nix?ref_type=heads#L43">flake inputs</a></li>
<li>Add the specialArgs <code>keys.user</code> as
seen <a href="https://gitlab.com/garuda-linux/infra-nix/-/blob/main/nixos/flake-module.nix?ref_type=heads#L38">here</a></li>
<li>Deploy &amp; apply the configuration</li>
</ul>
<h3 id="changing-docker-configurations"><a class="header" href="#changing-docker-configurations">Changing Docker configurations</a></h3>
<p>If configurations of services running in Docker containers need to be altered, one needs to edit the
corresponding <code>docker-compose.yml</code> (<code>./nix/docker-compose/$name</code>) file or <code>.env</code> file in the <code>secrets</code> directory (see
the secrets section for details on that topic).
The deployment is done the same way as with normal system configuration.</p>
<h3 id="updating-docker-containers"><a class="header" href="#updating-docker-containers">Updating Docker containers</a></h3>
<p>Docker containers sometimes use the <code>latest</code> tag in case no current tag is available or in the case of services like
Piped and Searx, where it is often crucial to have the latest build to bypass Google's restrictions.
Containers using the <code>latest</code> tag are automatically updated via <a href="https://containrrr.dev/watchtower/">watchtower</a> daily.
The remaining ones can be updated by changing their version in the corresponding <code>docker-compose.yml</code> and then
running <code>deploy</code> &amp; <code>apply</code>.
If containers are to be updated manually, this can be achieved by connecting to the host,
running <code>nixos-container root-login $containername</code>, and executing:</p>
<pre><code class="language-sh">cd /var/garuda/docker-compose-runner/$name/ # replace $name with the actual docker-compose.yml or autocomplete via tab
sudo docker compose pull
sudo docker compose up -d
</code></pre>
<p>The updated containers will be pulled and automatically recreated using the new images.</p>
<h3 id="rotating-ipv6"><a class="header" href="#rotating-ipv6">Rotating IPv6</a></h3>
<p>Sometimes it is needed to rotate the available IPv6 addresses to solve the current ones being rate-limited for outgoing
requests of Piped, Searx, etc.
This can be achieved by editing the hosts Nix file <code>immortalis.nix</code>, replacing the existing values of
the <code>networking.interfaces."eth0".ipv6.addresses</code> keys
seen <a href="https://gitlab.com/garuda-linux/infra-nix/-/blob/main/nixos/hosts/immortalis.nix?ref_type=heads#L30">here</a>.
Then, proceed doing the same with
the <a href="https://gitlab.com/garuda-linux/infra-nix/-/blob/main/nixos/hosts/immortalis.nix?ref_type=heads#L219">squid configuration</a>.
IPv6 addresses need to be generated from our available /64 subnet space and can't be chosen completely random.
To ease the process, a command called <code>ipv6-generator</code> is available in this git repos' devshell.</p>
<h3 id="checking-whether-backups-were-successful"><a class="header" href="#checking-whether-backups-were-successful">Checking whether backups were successful</a></h3>
<p>To check whether backups to Hetzner are still working as expected, connect to the server and execute the following:</p>
<pre><code class="language-sh">systemctl status borgbackup-job-backupToHetzner
</code></pre>
<p>This should yield a successful unit state. The only exception is having an exit code != <code>0</code> due to files having changed
during the run.</p>
<h3 id="updating-chaotic-aur-toolbox"><a class="header" href="#updating-chaotic-aur-toolbox">Updating Chaotic-AUR toolbox</a></h3>
<p>This needs to be done by updating the flake input (git repo URL of the
website) <a href="https://gitlab.com/garuda-linux/infra-nix/-/blob/main/nix/flake.nix?ref_type=heads#L44">src-chaotic-toolbox</a>:</p>
<pre><code class="language-sh">cd nix
nix flake lock --update-input src-chaotic-toolbox # toolbox
</code></pre>
<p>After that deploy as usual by running <code>deploy</code> and <code>apply</code>. The commit and corresponding hash will be updated and NixOS
will use it to build the toolbox using the new revision automatically.</p>
<h3 id="creating-new-docker-compose-configs"><a class="header" href="#creating-new-docker-compose-configs">Creating new Docker Compose configs</a></h3>
<p>In case a new service needs to be added to the Docker Compose runner,
one can either write the needed Nix expressions directly,
or use <a href="https://github.com/aksiksi/compose2nix">compose2nix</a>
to transform an existing <code>docker-compose.yml</code> to valid Nix expressions.
Using native Nix expressions has the advantage of being more flexible and easier to maintain,
as well as taking advantage of Systemd service management, e.g., by restarting crashed containers.
This was not working reliably with our <code>docker-compose-runner</code> module, which simply started
existing <code>docker-compose.yml</code> files.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="important-links"><a class="header" href="#important-links">Important links</a></h1>
<p>This is a collection of important links when working with the infrastructure:</p>
<h2 id="most-important"><a class="header" href="#most-important">Most important</a></h2>
<ul>
<li><a href="https://github.com/garuda-linux/infrastructure-nix">The infrastructure-nix repository</a></li>
</ul>
<h2 id="nix-related"><a class="header" href="#nix-related">Nix-related</a></h2>
<ul>
<li><a href="https://numtide.github.io/devshell/">Devshell documentation</a></li>
<li><a href="https://flake.parts">Flake-parts documentation</a>
<ul>
<li><a href="https://flake.parts/options/pre-commit-hooks-nix">Pre-commit-hooks flake-module</a></li>
</ul>
</li>
<li><a href="https://mipmip.github.io/home-manager-option-search/">Home Manager options search</a></li>
<li><a href="https://nixos-mailserver.readthedocs.io/en/latest/setup-guide.html">NixOS mailserver documentation</a></li>
<li><a href="https://nixos.org/manual/nixos/stable/">The Nix documentation</a></li>
<li><a href="https://search.nixos.org">The Nix package and option search</a></li>
</ul>
<h2 id="tools-documentation"><a class="header" href="#tools-documentation">Tools documentation</a></h2>
<ul>
<li><a href="https://github.com/chaotic-aur/toolbox">Chaotic toolbox</a></li>
<li><a href="./services/chaotic-4.0.html">Chaotic infra 4.0</a></li>
<li><a href="https://github.com/rust-lang/mdBook">mdBook</a></li>
</ul>
<h2 id="web-interfaces"><a class="header" href="#web-interfaces">Web interfaces</a></h2>
<ul>
<li><a href="https://syncthing-build.garudalinux.net/">Chaotic-AUR Syncthing</a></li>
<li><a href="https://dash.cloudflare.com">Cloudflare Dashboard</a></li>
<li><a href="https://garudalinux.freshping.io/">Freshping</a></li>
<li><a href="https://garudalinux.freshstatus.io/admin/incidents/public">Freshstatus</a></li>
<li><a href="https://accounts.hetzner.com/">Hetzner Robot</a></li>
<li><a href="https://matrixadmin.garudalinux.net">Matrix Admin</a></li>
<li><a href="https://app.netdata.cloud">Netdata</a></li>
<li><a href="https://developer.mend.io/github/garuda-linux">Renovate Dashboard</a></li>
<li><a href="https://login.tailscale.com/">Tailscale</a></li>
</ul>
<h2 id="services-to-be-administrated"><a class="header" href="#services-to-be-administrated">Services to be administrated</a></h2>
<ul>
<li><a href="https://vault.garudalinux.org">Vaultwarden</a></li>
<li><a href="https://forum.garudalinux.org">Discourse</a></li>
<li><a href="https://aur.chaotic.cx">Chaotic-AUR</a></li>
<li><a href="https://element.garudalinux.org">Element</a></li>
<li><a href="https://ffsync.garudalinux.org">Firefox syncserver</a></li>
<li><a href="https://lemmy.garudalinux.org">Lemmy</a></li>
<li><a href="https://lingva.garudalinux.org">Lingva</a></li>
<li><a href="https://social.garudalinux.org">Mastodon</a></li>
<li><a href="https://matrix.garudalinux.org">Matrix</a></li>
<li>Matrix Discord bridge (internal only)</li>
<li>Matrix IRC bridge (internal only)</li>
<li>Matrix Telegram bridge (internal only)</li>
<li><a href="https://cloud.garudalinux.org">Nextcloud</a></li>
<li><a href="https://bin.garudalinux.org">PrivateBin</a></li>
<li><a href="https://reddit.garudalinux.org">Redlib</a></li>
<li><a href="https://searx.garudalinux.org">SearxNG</a></li>
<li><a href="https://irc.garudalinux.org">TheLounge</a></li>
<li><a href="https://search.garudalinux.org">Whoogle</a></li>
<li><a href="https://wiki.garudalinux.org">WikiJs</a></li>
</ul>
<h2 id="additional-pages"><a class="header" href="#additional-pages">Additional pages</a></h2>
<ul>
<li><a href="https://start.garudalinux.org">Startpage</a>
<ul>
<li>This one needs to be updated by pulling latest changes from the repository. It lives inside the <code>docker</code>
nixos-container, <code>/var/garuda/docker-compose-runner/docker/startpage</code>.</li>
</ul>
</li>
<li><a href="https://garudalinux.org">Website</a>
<ul>
<li>This one is hosted on Cloudflare pages and will automatically update
whenever a new commit is pushed to the repository.
See commit pipelines for more information.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="users"><a class="header" href="#users">Users</a></h1>
<p>Multiple kinds of users can make use of our infrastructure. A current list of users is available <a href="./users/current_users.html">here</a>.</p>
<h2 id="adding-new-users"><a class="header" href="#adding-new-users">Adding new users</a></h2>
<p>New users can be added by supplying a fitting configuration in the <code>users.nix</code> module.
In case of a password being required, its hash needs to be generated as follows:</p>
<pre><code class="language-sh">nix-shell -p mkpasswd --run 'mkpasswd -sm bcrypt' &gt; /path/to/hashedPasswordFile
</code></pre>
<p>The file then needs to be <code>ansible-vault</code> encrypted and added to our <a href="https://gitlab.com/garuda-linux/infra-nix-secrets">secrets</a> repository.
This one is only available to members of our GitLab org and usually is cloned as git submodule to <code>./secrets</code>.</p>
<h2 id="onboarding-a-new-admin"><a class="header" href="#onboarding-a-new-admin">Onboarding a new admin</a></h2>
<p>After confirming the trustworthiness of a new admin, the following actions need to be executed:</p>
<ul>
<li>Add them to the <a href="./users/current_users.html#admins">admin users</a></li>
<li>Add their ssh public key to the <a href="https://gitlab.com/garuda-linux/infra-nix/-/blob/main/flake.nix?ref_type=heads#L59">flake inputs</a> and <a href="https://gitlab.com/garuda-linux/infra-nix/-/blob/main/nixos/flake-module.nix?ref_type=heads#L38">specialArgs</a></li>
<li>Make them an owner of the <a href="https://gitlab.com/garuda-linux">GitLab organization</a></li>
<li>Add them to our <a href="https://vault.garudalinux.org">Bitwarden organization</a> to allow access to passwords and email accounts</li>
<li>Add them to the Cloudflare Account</li>
<li>Make them an admin of <a href="https://forum.garudalinux.org">Discourse</a></li>
<li>Make them an admin of <a href="https://matrix.garudalinux.org">Matrix</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="users-1"><a class="header" href="#users-1">Users</a></h1>
<p>These are the people who are currently allowed to use our servers.</p>
<h2 id="admins"><a class="header" href="#admins">Admins</a></h2>
<p>Admins have root access to all servers and may therefore change everything.
They are responsible for the well-being of the infrastructure and its development.</p>
<pre><code class="language-nix">    */
    users.nico = {
      extraGroups = [ "wheel" "docker" "chaotic_op" ];
      home = "/home/nico";
      isNormalUser = true;
      openssh.authorizedKeys.keyFiles = [ keys.nico ];
      hashedPasswordFile = "/var/garuda/secrets/pass/nico";
      uid = lib.mkIf garuda-lib.unifiedUID 1001;
    };
    users.sgs = {
      extraGroups = [ "wheel" ];
      home = "/home/sgs";
      isNormalUser = true;
      openssh.authorizedKeys.keys = [
        "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDxBY8TX0iEQkf3Bym+3XVlrk8OLOwHOrj7Uy+WxjncOkkutyZ1WsY9liF4j9yjptyQG7Lx8OM8q44NE6+Rk1OXJXMF7CZ4Jq/WvMVnh2zKyNnF8wHBcspsAdG90wCxo6OmNpnY/rRRlNwwnore7raF2PrERtSlsEvLsUgvspYQ8cnLwerJP43QeETlpE1oR0FrbXWQet0I63Ky6UDEp07x0yee21VHnAG74rjGeFGwJBmCPSxnfGVNhCaR0zyu9+hh222liBrlilYm8nqLlsYGZCXiVdOxXJbBy89EVpHds7Lutf+TAYwsPGZf7U4k+g2Jx8N0JHXyzVZa0zS+I48+tqBBflEOqU9oEfGuz4cU/qWys5soLcRX2p9td+RF3OEdBKlTW4UYsINJUri6QSEUrsGaXqQZy8Ds2FBdUpb4pmFVlo9+4qRouiI80a5xVa7a1E5eS5xK5BzWH4fNg5SqtT5L9i2i1ocZp7FA0oa+ixnXNiC1umPZaY/9s+5fh1s= sgs-linux@shell.sf.net"
      ];
      hashedPasswordFile = "/var/garuda/secrets/pass/sgs";
      uid = lib.mkIf garuda-lib.unifiedUID 1002;
    };
    users.tne = {
      extraGroups = [ "wheel" "docker" "chaotic_op" ];
      home = "/home/tne";
      isNormalUser = true;
      openssh.authorizedKeys.keyFiles = [ keys.tne ];
      hashedPasswordFile = "/var/garuda/secrets/pass/tne";
      uid = lib.mkIf garuda-lib.unifiedUID 1003;
    };
    /*
</code></pre>
<h2 id="maintainers"><a class="header" href="#maintainers">Maintainers</a></h2>
<p>Maintainers have restricted access, which allows them to use <code>buildiso</code> to build new ISO files via the <code>iso-runner</code> container.</p>
<pre><code class="language-nix">    */
    users.frank = {
      home = "/home/frank";
      isNormalUser = true;
      openssh.authorizedKeys.keyFiles = lib.mkIf config.services.garuda-iso.enable [ keys.frank ];
      shell = lib.mkIf (!config.services.garuda-iso.enable) "${pkgs.util-linux}/bin/nologin";
      uid = lib.mkIf garuda-lib.unifiedUID 1007;
    };
    /*
</code></pre>
<h2 id="chaotic-aur-maintainers"><a class="header" href="#chaotic-aur-maintainers">Chaotic-AUR maintainers</a></h2>
<p>Chaotic-AUR maintainers have access to the builder containers of our infrastructure.
They may operate the repository by doing all kinds of packaging-related tasks such as adding or removing those.</p>
<pre><code class="language-nix">    */
    users.technetium = {
      extraGroups = lib.mkIf garuda-lib.chaoticUsers [ "chaotic_op" ];
      home = "/home/technetium";
      isNormalUser = true;
      openssh.authorizedKeys.keyFiles = lib.mkIf garuda-lib.chaoticUsers [ keys.technetium1 ];
      shell = lib.mkIf (!garuda-lib.chaoticUsers) "${pkgs.util-linux}/bin/nologin";
      uid = lib.mkIf garuda-lib.unifiedUID 1004;
    };
    users.alexjp = {
      extraGroups = lib.mkIf garuda-lib.chaoticUsers [ "chaotic_op" ];
      home = "/home/alexjp";
      isNormalUser = true;
      openssh.authorizedKeys.keyFiles = lib.mkIf garuda-lib.chaoticUsers [ keys.alexjp ];
      shell = lib.mkIf (!garuda-lib.chaoticUsers) "${pkgs.util-linux}/bin/nologin";
      uid = lib.mkIf garuda-lib.unifiedUID 1005;
    };
    users.xiota = {
      extraGroups = lib.mkIf garuda-lib.chaoticUsers [ "chaotic_op" ];
      home = "/home/xiota";
      isNormalUser = true;
      openssh.authorizedKeys.keyFiles = lib.mkIf garuda-lib.chaoticUsers [ keys.xiota ];
      shell = lib.mkIf (!garuda-lib.chaoticUsers) "${pkgs.util-linux}/bin/nologin";
      uid = lib.mkIf garuda-lib.unifiedUID 1006;
    };
    /*
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="immortalis-hetzner-dedicated"><a class="header" href="#immortalis-hetzner-dedicated">immortalis (Hetzner dedicated)</a></h2>
<h3 id="general"><a class="header" href="#general">General</a></h3>
<p>This system utilizes a NixOS host which uses <a href="https://nixos.wiki/wiki/NixOS_Containers">nixos-containers</a> to build declarative <code>systemd-nspawn</code> machines for different purposes. To make the best use of the available resources, common directories are shared between containers. This includes <code>/home</code> (home-manager / NixOS configurations writing to home are generated by the host and disabled for the containers), Pacman and Chaotic cache, the <code>/nix</code> directory, and a few others. Further details can be found in the <a href="hhttps://gitlab.com/garuda-linux/infra-nix/-/blob/main/nixos/hosts/immortalis/containers.nix">Nix expression</a> of the host.</p>
<p>All directories containing important data were mapped to <code>/data_1</code> and <code>/data_2</code> to have them all in one place. The first mostly contains web services' files, the latter only builds related directories such as the Pacman cache.</p>
<p>The current line-up looks as follows:</p>
<pre><code class="language-sh">nico@immortalis ~&gt; machinectl
MACHINE        CLASS     SERVICE        OS    VERSION ADDRESSES
chaotic-v4     container systemd-nspawn nixos 24.11   10.0.5.140…
docker         container systemd-nspawn nixos 24.11   10.0.5.100…
docker-proxied container systemd-nspawn nixos 24.11   10.0.5.110…
forum          container systemd-nspawn nixos 24.11   10.0.5.70…
github-runner  container systemd-nspawn nixos 24.11   10.0.5.130…
iso-runner     container systemd-nspawn nixos 24.11   10.0.5.40…
lemmy          container systemd-nspawn nixos 24.11   10.0.5.120…
mastodon       container systemd-nspawn nixos 24.11   10.0.5.80…
mongodb        container systemd-nspawn nixos 24.11   10.0.5.60…
postgres       container systemd-nspawn nixos 24.11   10.0.5.50…
temeraire      container systemd-nspawn nixos 24.11   10.0.5.20…
web-front      container systemd-nspawn nixos 24.11   10.0.5.10…
</code></pre>
<p>We are seeing:</p>
<ul>
<li>1 ISO builder (<code>iso-runner</code>)</li>
<li>1 reverse proxy serving all the websites and services (<code>web-front</code>)</li>
<li>2 Docker dedicated nspawn containers (<code>docker</code> &amp; <code>docker-proxied</code>)</li>
<li>3 Chaotic-AUR builders ( <code>chaotic-v4</code>, <code>github-runner</code> &amp; <code>temeraire</code>)</li>
<li>6 app dedicated containers (<code>forum</code>, <code>lemmy</code>, <code>mastodon</code>, <code>mongodb</code> &amp; <code>postgres</code>)</li>
</ul>
<h3 id="connecting-to-the-server"><a class="header" href="#connecting-to-the-server">Connecting to the server</a></h3>
<p>After connecting to the host via <code>ssh -p 666 $user@116.202.208.112</code>, containers can generally be entered by running <code>nixos-container login $containername</code>, eg. <code>nixos-container login web-front</code>. Some containers may also be connected via SSH using the following ports:</p>
<ul>
<li>22: <code>temeraire</code> (needs to be 22 to allow pushing packages to the main Chaotic-AUR node via rsync)</li>
<li>224: <code>forum</code></li>
<li>225: <code>docker</code></li>
<li>227: <code>iso-runner</code></li>
<li>228: <code>web-front</code></li>
<li>229: <code>postgres</code> (access the database in <code>127.0.0.1</code> via <code>ssh -p 229 $user@116.202.208.112 -L 5432:127.0.0.1:5432</code>)</li>
<li>400: <code>chaotic-v4</code></li>
</ul>
<h3 id="docker-containers"><a class="header" href="#docker-containers">Docker containers</a></h3>
<p>Some services not packaged in NixOS or are easier to deploy this way are serviced via the Docker engine. This contains services like Piped, Whoogle, and Matrix. We use a custom <a href="https://gitlab.com/garuda-linux/infra-nix/-/blob/main/nix/garuda/services/docker-compose-runner/docker-compose-runner.nix?ref_type=heads">NixOS module</a> to deploy those with the rest of the system. Secrets are handled via our secret management which consists of a git submodule <code>secret</code> (private repo with <code>ansible-vault</code> encrypted files) and <code>garuda-lib</code> (see secrets section). Those contain a <code>docker-compose</code> directory in which the <code>.env</code> files for the <code>docker-compose.yml</code> are stored.</p>
<h3 id="chaotic-aur--repository"><a class="header" href="#chaotic-aur--repository">Chaotic-AUR / repository</a></h3>
<p>Our repository leverages <a href="https://aur.chaotic.cx">Chaotic-AUR's</a> <a href="https://github.com/chaotic-aur/toolbox">toolbox</a> to provide the main node for the <code>[chaotic-aur]</code> repository as well as two more instances building the <code>[garuda]</code> and <code>[chaotic-kde]</code> repositories. Users of the <code>chaotic_op</code> group may build packages on the corresponding nixos-container via the <a href="https://github.com/chaotic-aur/toolbox/blob/main/README.md">chaotic</a> command:</p>
<pre><code class="language-sh">chaotic get $package # pull PKGBUILD
chaotic mkd $package # build package in the previously cloned directory
chaotic bump $package # increment pkgver of $package by 0.1 to allow a rebuild
chaotic rm $package # remove the package from the repository
</code></pre>
<p>Further information may be obtained by clicking <code>chaotic</code> seen above. The corresponding builders are:</p>
<ul>
<li><code>[chaotic-aur]</code>: <code>temeraire</code></li>
</ul>
<h3 id="squid-proxy"><a class="header" href="#squid-proxy">Squid proxy</a></h3>
<p>Squid is being installed on the host machine to proxy outgoing requests via random IPv6 addresses of the /64 subnet Hetzner provides for services that need it, eg. Piped, the Chaotic-AUR builders, and other services that are getting rate limited quickly. The process is not entirely automated, which means that we currently have a pool of IPv6 addresses active and need to switch them whenever those are getting rate-limited again.
Since we supplied an invalid IPv4 to force outgoing IPv6, the log files were somewhat cluttered by (expected) errors. Systemd-unit logging has been set to <code>LogLevelMax=1</code> to un-clutter the journal and needs to be increased again if debugging needs to be done.</p>
<h3 id="backups"><a class="header" href="#backups">Backups</a></h3>
<p>Backups are provided by daily Borg runs. Only the <code>/data_1</code> directory is backed up (minus <code>/data_1/{dockercache,dockerdata}</code>) as the rest are either Nix-generated or build-related files that can easily recovered from another repository mirror. The corresponding systemd-unit is named <code>borgbackup-job-backupToHetzner</code>.</p>
<h3 id="tailscale--mesh-network"><a class="header" href="#tailscale--mesh-network">Tailscale / mesh network</a></h3>
<p>While Tailscale was commonly used to connect multiple VMs before, this server only has it active on the host. However, we are leveraging Tailscale's <a href="https://tailscale.com/kb/1019/subnets/">subnet router</a> feature to serve the <code>10.0.5.0/24</code> subnet via Tailscale, which means that other Tailscale clients may access the <code>nixos-containers</code> via their IP if <code>tailscale up --accept-routes</code> was used to set up the service.</p>
<h3 id="nix-expression"><a class="header" href="#nix-expression">Nix expression</a></h3>
<pre><code class="language-nix">{ garuda-lib
, pkgs
, config
, ...
}: {
  imports = [
    ../modules
    ./immortalis/containers.nix
    ./immortalis/hardware-configuration.nix
  ];

  # Increase /tmp &amp; /run size to make better use of RAM
  boot = {
    kernelPackages = pkgs.linuxPackages_6_6;
    loader.systemd-boot.enable = true;
    runSize = "50%";
    tmp = {
      tmpfsSize = "95%";
      useTmpfs = true;
    };
  };

  # Network configuration with a bridge interface
  networking = {
    defaultGateway = "116.202.208.65";
    defaultGateway6 = {
      address = "fe80::1";
      interface = "eth0";
    };
    hostName = "immortalis";
    interfaces = {
      "eth0" = {
        ipv4.addresses = [
          {
            address = "116.202.208.112";
            prefixLength = 26;
          }
        ];
        ipv6.addresses = [
          # Random outgoing
          {
            address = "2a01:4f8:2200:30ac:cf2d:7d73:eddf:8871";
            prefixLength = 64;
          }
          {
            address = "2a01:4f8:2200:30ac:5b38:dbde:e5a7:91b2";
            prefixLength = 64;
          }
          {
            address = "2a01:4f8:2200:30ac:fa33:0d97:0755:6833";
            prefixLength = 64;
          }
          {
            address = "2a01:4f8:2200:30ac:8f15:81f6:355c:d9d6";
            prefixLength = 64;
          }
          {
            address = "2a01:4f8:2200:30ac:4436:e5e7:2236:0d77";
            prefixLength = 64;
          }
          {
            address = "2a01:4f8:2200:30ac:1ea4:1794:1963:b8da";
            prefixLength = 64;
          }
          {
            address = "2a01:4f8:2200:30ac:5628:7e9f:d8ec:544d";
            prefixLength = 64;
          }
          {
            address = "2a01:4f8:2200:30ac:d830:ce99:e2b7:3e43";
            prefixLength = 64;
          }
          {
            address = "2a01:4f8:2200:30ac:edc9:2d08:2b32:e532";
            prefixLength = 64;
          }
          {
            address = "2a01:4f8:2200:30ac:a833:0fd7:29d4:5309";
            prefixLength = 64;
          }
        ];
      };
    };
    # Specify these here to allow containers to access
    # our services from the internal network via NAT reflection
    nat.forwardPorts = [
      {
        # web-front (HTTP)
        destination = "10.0.5.10:80";
        loopbackIPs = [ "116.202.208.112" ];
        proto = "tcp";
        sourcePort = 80;
      }
      {
        # web-front (HTTPS)
        destination = "10.0.5.10:443";
        loopbackIPs = [ "116.202.208.112" ];
        proto = "tcp";
        sourcePort = 443;
      }
      {
        # web-front (HTTPS)
        destination = "10.0.5.10:443";
        loopbackIPs = [ "116.202.208.112" ];
        proto = "udp";
        sourcePort = 443;
      }
      {
        # web-front (Matrix)
        destination = "10.0.5.10:8448";
        loopbackIPs = [ "116.202.208.112" ];
        proto = "tcp";
        sourcePort = 8448;
      }
      # Here because we need to take advantage of NAT reflection.
      # In general, SSH ports should not be here.
      {
        # chaotic-v4 (SSH)
        destination = "10.0.5.140:22";
        loopbackIPs = [ "116.202.208.112" ];
        proto = "tcp";
        sourcePort = 400;
      }
    ];
    firewall.trustedInterfaces = [ "br0" ];
  };

  # OpenSSH on another port to keep Chaotic's main node working
  services.openssh.ports = [ 666 ];

  # Make use of all threads!
  security.allowSimultaneousMultithreading = true;

  # Raise limits to support many containers
  # (from LXC's recommendedSysctlSettings)
  boot.kernel.sysctl = {
    "fs.inotify.max_user_instances" = 1048576;
    "fs.inotify.max_user_watches" = 1048576;
    "kernel.dmesg_restrict" = 1;
    "kernel.keys.maxkeys" = 2000;
    "kernel.pid_max" = 4194303;
    "net.ipv4.neigh.default.gc_thresh3" = 8192;
    "net.ipv6.neigh.default.gc_thresh3" = 8192;
  };

  # Improve nspawn container performance since we grant all capabilities anyway
  # https://github.com/systemd/systemd/issues/18370#issuecomment-768645418
  environment.variables.SYSTEMD_SECCOMP = "0";

  # Custom tailscale configuration to advertise our bridge's subnet route
  systemd.services.tailscale-autoconnect.script = with pkgs; ''
    sleep 2
    status="$(${tailscale}/bin/tailscale status -json | ${jq}/bin/jq -r .BackendState)"
    if [ $status = "Running" ]; then
      exit 0
    fi
    ${tailscale}/bin/tailscale up --authkey ${garuda-lib.secrets.tailscale.authkey} \
      --advertise-routes=10.0.5.0/24
  '';

  # We want to have same UID's in all containers to allow sharing home directories
  garuda-lib.unifiedUID = true;

  # Monitor a few services of the containers
  services = {
    netdata.configDir = {
      "go.d/postgres.conf" = pkgs.writeText "postgres.conf" ''
        jobs:
          - name: postgres
            dsn: 'postgres://netdata:netdata@10.0.5.50:5432/'
      '';
      "go.d/squidlog.conf" = pkgs.writeText "squidlog.conf" ''
        jobs:
          - name: squid
            path: /var/log/squid/access.log
            log_type: csv
            csv_config:
              format: '- resp_time client_address result_code resp_size req_method - - hierarchy mime_type'
      '';
      "go.d/web_log.conf" = pkgs.writeText "web_log.conf" ''
        jobs:
          - name: nginx
            path: /var/log/nginx/access.log
      '';
    };
    smartd = {
      enable = true;
      extraOptions = [ "-A /var/log/smartd/" "--interval=600" ];
    };
  };

  # Fix permissions of nginx log files to allow Netdata to read it (gets reset frequently)
  system.activationScripts.netdata = ''chown 60:netdata -R /var/log/nginx'';

  # Backup configurations to Hetzner storage box
  programs.ssh.macs = [ "hmac-sha2-512" ];
  services.borgbackup.jobs = {
    backupToHetzner = {
      compression = "auto,zstd";
      doInit = true;
      encryption = {
        mode = "repokey-blake2";
        passCommand = "cat /var/garuda/secrets/backup/repo_key";
      };
      environment = {
        BORG_RSH = "ssh -i /var/garuda/secrets/backup/ssh_immortalis -p 23";
      };
      exclude = [ "/data_1/dockercache" "/data_1/dockerdata" ];
      paths = [ "/data_1" ];
      prune.keep = {
        within = "1d";
        daily = 3;
        weekly = 2;
        monthly = 2;
      };
      repo = "u342919@u342919.your-storagebox.de:./immortalis";
      startAt = "daily";
    };
  };

  # A proxy server making use of our IPv6 IP addresses
  # traffic sent through the proxy is only allowing IPv6 connections
  services.squid = {
    enable = true;
    extraConfig = ''
      forwarded_for delete
      dns_nameservers 2606:4700:4700::1111

      acl tenth random 1/10
      acl ninth random 1/9
      acl eighth random 1/8
      acl seventh random 1/7
      acl sixth random 1/6
      acl fifth random 1/5
      acl fourth random 1/4
      acl third random 1/3
      acl half random 1/2

      # Invalid IP
      tcp_outgoing_address 10.254.254.254
      tcp_outgoing_address 2a01:4f8:2200:30ac:cf2d:7d73:eddf:8871 tenth
      tcp_outgoing_address 2a01:4f8:2200:30ac:5b38:dbde:e5a7:91b2 ninth
      tcp_outgoing_address 2a01:4f8:2200:30ac:fa33:0d97:0755:6833 eighth
      tcp_outgoing_address 2a01:4f8:2200:30ac:8f15:81f6:355c:d9d6 seventh
      tcp_outgoing_address 2a01:4f8:2200:30ac:4436:e5e7:2236:0d77 sixth
      tcp_outgoing_address 2a01:4f8:2200:30ac:1ea4:1794:1963:b8da fifth
      tcp_outgoing_address 2a01:4f8:2200:30ac:5628:7e9f:d8ec:544d fourth
      tcp_outgoing_address 2a01:4f8:2200:30ac:d830:ce99:e2b7:3e43 third
      tcp_outgoing_address 2a01:4f8:2200:30ac:edc9:2d08:2b32:e532 half
      tcp_outgoing_address 2a01:4f8:2200:30ac:a833:0fd7:29d4:5309

      # Invalid IP
      udp_outgoing_address 10.254.254.254
      udp_outgoing_address 2a01:4f8:2200:30ac:cf2d:7d73:eddf:8871 tenth
      udp_outgoing_address 2a01:4f8:2200:30ac:5b38:dbde:e5a7:91b2 ninth
      udp_outgoing_address 2a01:4f8:2200:30ac:fa33:0d97:0755:6833 eighth
      udp_outgoing_address 2a01:4f8:2200:30ac:8f15:81f6:355c:d9d6 seventh
      udp_outgoing_address 2a01:4f8:2200:30ac:4436:e5e7:2236:0d77 sixth
      udp_outgoing_address 2a01:4f8:2200:30ac:1ea4:1794:1963:b8da fifth
      udp_outgoing_address 2a01:4f8:2200:30ac:5628:7e9f:d8ec:544d fourth
      udp_outgoing_address 2a01:4f8:2200:30ac:d830:ce99:e2b7:3e43 third
      udp_outgoing_address 2a01:4f8:2200:30ac:edc9:2d08:2b32:e532 half
      udp_outgoing_address 2a01:4f8:2200:30ac:a833:0fd7:29d4:5309

      # This does not rotate the logs, but asks squid to reopen the log file so that logrotate can rotate it
      logfile_rotate 0
    '';
    proxyAddress = "10.0.5.1";
  };
  systemd.services.squid = {
    serviceConfig = {
      Restart = "always";
      RestartSec = 10;
      # Shut off all logging but level 1 errors as we get spamming a lot due to
      # not being able to use our invalid address 10.254.254.254
      LogLevelMax = 1;
    };
    startLimitIntervalSec = 80;
    startLimitBurst = 6;
  };
  services.logrotate.settings.squid = {
    files = "/var/log/squid/*.log";
    frequency = "daily";
    su = "squid squid";
    rotate = 5;
    compress = true;
    delaycompress = true;
    postrotate = "${config.systemd.package}/bin/systemctl kill --signal=SIGUSR1 squid";
  };

  # Can't really instantly remove this, need to find an alternative first
  nixpkgs.config.permittedInsecurePackages = [ "squid-6.8" ];

  # Adapt Nix to our core-count
  nix.settings.max-jobs = 8;

  system.stateVersion = "23.05";
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docker"><a class="header" href="#docker">docker</a></h1>
<h2 id="general-1"><a class="header" href="#general-1">General</a></h2>
<p>This container consists of our <code>docker-compose-runner</code> module, which deploys all Docker-based services that don't need to proxied outgoing requests. For the other ones, have a look <a href="nixos-containers/./docker-proxied.html">here</a>.</p>
<h2 id="nix-expression-1"><a class="header" href="#nix-expression-1">Nix expression</a></h2>
<pre><code class="language-nix">{ sources, ... }: {
  imports = sources.defaultModules ++ [
    ../modules
    ./docker/docker-compose.nix
  ];

  system.stateVersion = "23.05";
}
</code></pre>
<h3 id="docker-containers-1"><a class="header" href="#docker-containers-1">Docker containers</a></h3>
<pre><code class="language-nix"># Auto-generated using compose2nix v0.2.2-pre.
{ pkgs, lib, ... }:

{
  # Runtime
  virtualisation.docker = {
    enable = true;
    autoPrune.enable = true;
  };
  virtualisation.oci-containers.backend = "docker";

  # Containers
  virtualisation.oci-containers.containers."bitwarden" = {
    image = "vaultwarden/server:1.32.0";
    environment = {
      "DOMAIN" = "https://bitwarden.garudalinux.org";
      "SIGNUPS_ALLOWED" = "true";
      "SMTP_FROM" = "noreply@garudalinux.org";
      "SMTP_HOST" = "mail.garudalinux.org";
      "SMTP_PORT" = "587";
      "SMTP_SSL" = "false";
      "SMTP_USERNAME" = "noreply@garudalinux.org";
      "WEBSOCKET_ENABLED" = "true";
    };
    volumes = [
      "/var/garuda/docker-compose-runner/all-in-one/bitwarden:/data:rw"
    ];
    ports = [
      "8081:80/tcp"
    ];
    log-driver = "journald";
    extraOptions = [
      "--network-alias=bitwarden"
      "--network=all-in-one_default"
    ];
    environmentFiles = [
      "/var/garuda/secrets/docker-compose/all-in-one.env"
    ];
  };
  systemd.services."docker-bitwarden" = {
    serviceConfig = {
      Restart = lib.mkOverride 500 "always";
      RestartMaxDelaySec = lib.mkOverride 500 "1m";
      RestartSec = lib.mkOverride 500 "100ms";
      RestartSteps = lib.mkOverride 500 9;
    };
    after = [
      "docker-network-all-in-one_default.service"
    ];
    requires = [
      "docker-network-all-in-one_default.service"
    ];
    partOf = [
      "docker-compose-all-in-one-root.target"
    ];
    wantedBy = [
      "docker-compose-all-in-one-root.target"
    ];
    unitConfig.RequiresMountsFor = [
      "/var/garuda/docker-compose-runner/all-in-one/bitwarden"
    ];
  };
  virtualisation.oci-containers.containers."element_web" = {
    image = "vectorim/element-web:v1.11.73";
    volumes = [
      "/var/garuda/docker-compose-runner/all-in-one/matrix/element/config.json:/app/config.json:rw"
    ];
    ports = [
      "8084:80/tcp"
    ];
    dependsOn = [
      "matrix"
    ];
    log-driver = "journald";
    extraOptions = [
      "--network-alias=matrix_web"
      "--network=all-in-one_default"
    ];
    environmentFiles = [
      "/var/garuda/secrets/docker-compose/all-in-one.env"
    ];
  };
  systemd.services."docker-element_web" = {
    serviceConfig = {
      Restart = lib.mkOverride 500 "always";
      RestartMaxDelaySec = lib.mkOverride 500 "1m";
      RestartSec = lib.mkOverride 500 "100ms";
      RestartSteps = lib.mkOverride 500 9;
    };
    after = [
      "docker-network-all-in-one_default.service"
    ];
    requires = [
      "docker-network-all-in-one_default.service"
    ];
    partOf = [
      "docker-compose-all-in-one-root.target"
    ];
    wantedBy = [
      "docker-compose-all-in-one-root.target"
    ];
    unitConfig.RequiresMountsFor = [
      "/var/garuda/docker-compose-runner/all-in-one/matrix/element/config.json"
    ];
  };
  virtualisation.oci-containers.containers."homer" = {
    image = "b4bz/homer:v24.05.1";
    volumes = [
      "/var/garuda/docker-compose-runner/all-in-one/startpage:/www/assets:rw"
    ];
    ports = [
      "8083:8080/tcp"
    ];
    log-driver = "journald";
    extraOptions = [
      "--network-alias=homer"
      "--network=all-in-one_default"
    ];
  };
  systemd.services."docker-homer" = {
    serviceConfig = {
      Restart = lib.mkOverride 500 "always";
      RestartMaxDelaySec = lib.mkOverride 500 "1m";
      RestartSec = lib.mkOverride 500 "100ms";
      RestartSteps = lib.mkOverride 500 9;
    };
    after = [
      "docker-network-all-in-one_default.service"
    ];
    requires = [
      "docker-network-all-in-one_default.service"
    ];
    partOf = [
      "docker-compose-all-in-one-root.target"
    ];
    wantedBy = [
      "docker-compose-all-in-one-root.target"
    ];
    unitConfig.RequiresMountsFor = [
      "/var/garuda/docker-compose-runner/all-in-one/startpage"
    ];
  };
  virtualisation.oci-containers.containers."lemmy_lcs" = {
    image = "nowsci/lcs:20240801065204";
    environment = {
      "COMMUNITY_COUNT" = "50";
      "COMMUNITY_SORT_METHODS" = ''[ "TopAll", "TopDay" ]'';
      "COMMUNITY_TYPE" = "All";
      "LOCAL_URL" = "https://lemmy.garudalinux.org";
      "MINUTES_BETWEEN_RUNS" = "240";
      "NSFW" = "false";
      "POST_COUNT" = "50";
      "REMOTE_INSTANCES" = ''[ "beehaw.org", "lemmy.world", "lemmy.ml", "sh.itjust.works", "lemmy.one" ]'';
      "SECONDS_AFTER_COMMUNITY_ADD" = "17";
    };
    log-driver = "journald";
    extraOptions = [
      "--network-alias=lemmy_seeder"
      "--network=all-in-one_default"
    ];
  };
  systemd.services."docker-lemmy_lcs" = {
    serviceConfig = {
      Restart = lib.mkOverride 500 "always";
      RestartMaxDelaySec = lib.mkOverride 500 "1m";
      RestartSec = lib.mkOverride 500 "100ms";
      RestartSteps = lib.mkOverride 500 9;
    };
    after = [
      "docker-network-all-in-one_default.service"
    ];
    requires = [
      "docker-network-all-in-one_default.service"
    ];
    partOf = [
      "docker-compose-all-in-one-root.target"
    ];
    wantedBy = [
      "docker-compose-all-in-one-root.target"
    ];
  };
  virtualisation.oci-containers.containers."matrix" = {
    image = "matrixdotorg/synapse:v1.112.0";
    volumes = [
      "/var/garuda/docker-compose-runner/all-in-one/matrix/matrix:/data:rw"
    ];
    ports = [
      "8008:8008/tcp"
    ];
    log-driver = "journald";
    extraOptions = [
      "--network-alias=matrix"
      "--network=all-in-one_default"
    ];
  };
  systemd.services."docker-matrix" = {
    serviceConfig = {
      Restart = lib.mkOverride 500 "always";
      RestartMaxDelaySec = lib.mkOverride 500 "1m";
      RestartSec = lib.mkOverride 500 "100ms";
      RestartSteps = lib.mkOverride 500 9;
    };
    after = [
      "docker-network-all-in-one_default.service"
    ];
    requires = [
      "docker-network-all-in-one_default.service"
    ];
    partOf = [
      "docker-compose-all-in-one-root.target"
    ];
    wantedBy = [
      "docker-compose-all-in-one-root.target"
    ];
    unitConfig.RequiresMountsFor = [
      "/var/garuda/docker-compose-runner/all-in-one/matrix/matrix"
    ];
  };
  virtualisation.oci-containers.containers."matrix_admin" = {
    image = "awesometechnologies/synapse-admin:latest";
    ports = [
      "8085:80/tcp"
    ];
    dependsOn = [
      "matrix"
    ];
    log-driver = "journald";
    extraOptions = [
      "--network-alias=matrix_admin"
      "--network=all-in-one_default"
    ];
  };
  systemd.services."docker-matrix_admin" = {
    serviceConfig = {
      Restart = lib.mkOverride 500 "always";
      RestartMaxDelaySec = lib.mkOverride 500 "1m";
      RestartSec = lib.mkOverride 500 "100ms";
      RestartSteps = lib.mkOverride 500 9;
    };
    after = [
      "docker-network-all-in-one_default.service"
    ];
    requires = [
      "docker-network-all-in-one_default.service"
    ];
    partOf = [
      "docker-compose-all-in-one-root.target"
    ];
    wantedBy = [
      "docker-compose-all-in-one-root.target"
    ];
  };
  virtualisation.oci-containers.containers."matterbridge" = {
    image = "42wim/matterbridge:1.26";
    volumes = [
      "/var/garuda/docker-compose-runner/all-in-one/matterbridge/matterbridge.toml:/etc/matterbridge/matterbridge.toml:ro"
    ];
    dependsOn = [
      "matrix"
    ];
    log-driver = "journald";
    extraOptions = [
      "--network-alias=matterbridge"
      "--network=all-in-one_default"
    ];
  };
  systemd.services."docker-matterbridge" = {
    serviceConfig = {
      Restart = lib.mkOverride 500 "always";
      RestartMaxDelaySec = lib.mkOverride 500 "1m";
      RestartSec = lib.mkOverride 500 "100ms";
      RestartSteps = lib.mkOverride 500 9;
    };
    after = [
      "docker-network-all-in-one_default.service"
    ];
    requires = [
      "docker-network-all-in-one_default.service"
    ];
    partOf = [
      "docker-compose-all-in-one-root.target"
    ];
    wantedBy = [
      "docker-compose-all-in-one-root.target"
    ];
    unitConfig.RequiresMountsFor = [
      "/var/garuda/docker-compose-runner/all-in-one/matterbridge/matterbridge.toml"
    ];
  };
  virtualisation.oci-containers.containers."mautrix-telegram" = {
    image = "dock.mau.dev/mautrix/telegram";
    volumes = [
      "/var/garuda/docker-compose-runner/all-in-one/matrix/mautrix-telegram:/data:rw"
    ];
    log-driver = "journald";
    extraOptions = [
      "--health-cmd=! (grep -q 'System clock is wrong, set time offset to' /tmp/debug.log &amp;&amp; rm /tmp/debug.log &amp;&amp; kill -SIGINT 1)"
      "--health-interval=1m0s"
      "--health-timeout=10s"
      "--network-alias=mautrix-telegram"
      "--network=all-in-one_default"
    ];
  };
  systemd.services."docker-mautrix-telegram" = {
    serviceConfig = {
      Restart = lib.mkOverride 500 "always";
      RestartMaxDelaySec = lib.mkOverride 500 "1m";
      RestartSec = lib.mkOverride 500 "100ms";
      RestartSteps = lib.mkOverride 500 9;
    };
    after = [
      "docker-network-all-in-one_default.service"
    ];
    requires = [
      "docker-network-all-in-one_default.service"
    ];
    partOf = [
      "docker-compose-all-in-one-root.target"
    ];
    wantedBy = [
      "docker-compose-all-in-one-root.target"
    ];
    unitConfig.RequiresMountsFor = [
      "/var/garuda/docker-compose-runner/all-in-one/matrix/mautrix-telegram"
    ];
  };
  virtualisation.oci-containers.containers."nextcloud-aio-mastercontainer" = {
    image = "nextcloud/all-in-one:latest";
    environment = {
      "APACHE_IP_BINDING" = "10.0.5.100";
      "APACHE_PORT" = "11000";
    };
    volumes = [
      "/var/run/docker.sock:/var/run/docker.sock:ro"
      "nextcloud_aio_mastercontainer:/mnt/docker-aio-config:rw"
    ];
    ports = [
      "8080:8080/tcp"
    ];
    log-driver = "journald";
    extraOptions = [
      "--network-alias=nextcloud-aio-mastercontainer"
      "--network=all-in-one_default"
    ];
  };
  systemd.services."docker-nextcloud-aio-mastercontainer" = {
    serviceConfig = {
      Restart = lib.mkOverride 500 "always";
      RestartMaxDelaySec = lib.mkOverride 500 "1m";
      RestartSec = lib.mkOverride 500 "100ms";
      RestartSteps = lib.mkOverride 500 9;
    };
    after = [
      "docker-network-all-in-one_default.service"
      "docker-volume-nextcloud_aio_mastercontainer.service"
    ];
    requires = [
      "docker-network-all-in-one_default.service"
      "docker-volume-nextcloud_aio_mastercontainer.service"
    ];
    partOf = [
      "docker-compose-all-in-one-root.target"
    ];
    wantedBy = [
      "docker-compose-all-in-one-root.target"
    ];
    unitConfig.RequiresMountsFor = [
      "/var/run/docker.sock"
    ];
  };
  virtualisation.oci-containers.containers."privatebin" = {
    image = "privatebin/nginx-fpm-alpine:1.7.4";
    volumes = [
      "/var/garuda/docker-compose-runner/all-in-one/configs/privatebin.cfg.php:/srv/cfg/conf.php:rw"
      "/var/garuda/docker-compose-runner/all-in-one/privatebin:/srv/data:rw"
    ];
    ports = [
      "8082:8080/tcp"
    ];
    log-driver = "journald";
    extraOptions = [
      "--network-alias=privatebin"
      "--network=all-in-one_default"
    ];
  };
  systemd.services."docker-privatebin" = {
    serviceConfig = {
      Restart = lib.mkOverride 500 "always";
      RestartMaxDelaySec = lib.mkOverride 500 "1m";
      RestartSec = lib.mkOverride 500 "100ms";
      RestartSteps = lib.mkOverride 500 9;
    };
    after = [
      "docker-network-all-in-one_default.service"
    ];
    requires = [
      "docker-network-all-in-one_default.service"
    ];
    partOf = [
      "docker-compose-all-in-one-root.target"
    ];
    wantedBy = [
      "docker-compose-all-in-one-root.target"
    ];
    unitConfig.RequiresMountsFor = [
      "/var/garuda/docker-compose-runner/all-in-one/configs/privatebin.cfg.php"
      "/var/garuda/docker-compose-runner/all-in-one/privatebin"
    ];
  };
  virtualisation.oci-containers.containers."syncserver" = {
    image = "crazymax/firefox-syncserver:edge";
    environment = {
      "FF_SYNCSERVER_ACCESSLOG" = "true";
      "FF_SYNCSERVER_FORCE_WSGI_ENVIRON" = "true";
      "FF_SYNCSERVER_FORWARDED_ALLOW_IPS" = "*";
      "FF_SYNCSERVER_PUBLIC_URL" = "https://ffsync.garudalinux.org";
      "FF_SYNCSERVER_SQLURI" = "sqlite:////data/syncserver.db";
      "TZ" = "Europe/Berlin";
    };
    volumes = [
      "/var/garuda/docker-compose-runner/all-in-one/syncserver:/data:rw"
    ];
    ports = [
      "5001:5000/tcp"
    ];
    log-driver = "journald";
    extraOptions = [
      "--network-alias=syncserver"
      "--network=all-in-one_default"
    ];
    environmentFiles = [
      "/var/garuda/secrets/docker-compose/all-in-one.env"
    ];
  };
  systemd.services."docker-syncserver" = {
    serviceConfig = {
      Restart = lib.mkOverride 500 "always";
      RestartMaxDelaySec = lib.mkOverride 500 "1m";
      RestartSec = lib.mkOverride 500 "100ms";
      RestartSteps = lib.mkOverride 500 9;
    };
    after = [
      "docker-network-all-in-one_default.service"
    ];
    requires = [
      "docker-network-all-in-one_default.service"
    ];
    partOf = [
      "docker-compose-all-in-one-root.target"
    ];
    wantedBy = [
      "docker-compose-all-in-one-root.target"
    ];
    unitConfig.RequiresMountsFor = [
      "/var/garuda/docker-compose-runner/all-in-one/syncserver"
    ];
  };
  virtualisation.oci-containers.containers."thelounge" = {
    image = "thelounge/thelounge:4.4.3";
    volumes = [
      "/var/garuda/docker-compose-runner/all-in-one/thelounge:/var/opt/thelounge:rw"
    ];
    ports = [
      "9000:9000/tcp"
    ];
    log-driver = "journald";
    extraOptions = [
      "--network-alias=thelounge"
      "--network=all-in-one_default"
    ];
  };
  systemd.services."docker-thelounge" = {
    serviceConfig = {
      Restart = lib.mkOverride 500 "always";
      RestartMaxDelaySec = lib.mkOverride 500 "1m";
      RestartSec = lib.mkOverride 500 "100ms";
      RestartSteps = lib.mkOverride 500 9;
    };
    after = [
      "docker-network-all-in-one_default.service"
    ];
    requires = [
      "docker-network-all-in-one_default.service"
    ];
    partOf = [
      "docker-compose-all-in-one-root.target"
    ];
    wantedBy = [
      "docker-compose-all-in-one-root.target"
    ];
    unitConfig.RequiresMountsFor = [
      "/var/garuda/docker-compose-runner/all-in-one/thelounge"
    ];
  };
  virtualisation.oci-containers.containers."watchtower" = {
    image = "containrrr/watchtower:1.7.1";
    volumes = [
      "/var/run/docker.sock:/var/run/docker.sock:rw"
    ];
    cmd = [ "--cleanup" "matrix_web" "matrix_admin" "wikijs" "mongodb" "homer" "privatebin" "bitwarden" "thelounge" "syncserver" "nextcloud_app" "lemmy_seeder" ];
    log-driver = "journald";
    extraOptions = [
      "--network-alias=watchtower"
      "--network=all-in-one_default"
    ];
  };
  systemd.services."docker-watchtower" = {
    serviceConfig = {
      Restart = lib.mkOverride 500 "always";
      RestartMaxDelaySec = lib.mkOverride 500 "1m";
      RestartSec = lib.mkOverride 500 "100ms";
      RestartSteps = lib.mkOverride 500 9;
    };
    after = [
      "docker-network-all-in-one_default.service"
    ];
    requires = [
      "docker-network-all-in-one_default.service"
    ];
    partOf = [
      "docker-compose-all-in-one-root.target"
    ];
    wantedBy = [
      "docker-compose-all-in-one-root.target"
    ];
    unitConfig.RequiresMountsFor = [
      "/var/run/docker.sock"
    ];
  };
  virtualisation.oci-containers.containers."wikijs" = {
    image = "requarks/wiki:2.5";
    environment = {
      "DB_HOST" = "10.0.5.50";
      "DB_NAME" = "wikijs";
      "DB_PORT" = "5432";
      "DB_TYPE" = "postgres";
      "DB_USER" = "wikijs";
    };
    volumes = [
      "/var/garuda/docker-compose-runner/all-in-one/wikijs/assets:/wiki/assets/favicons:rw"
    ];
    ports = [
      "3001:3000/tcp"
    ];
    log-driver = "journald";
    extraOptions = [
      "--network-alias=wikijs"
      "--network=all-in-one_default"
    ];
    environmentFiles = [
      "/var/garuda/secrets/docker-compose/all-in-one.env"
    ];
  };
  systemd.services."docker-wikijs" = {
    serviceConfig = {
      Restart = lib.mkOverride 500 "always";
      RestartMaxDelaySec = lib.mkOverride 500 "1m";
      RestartSec = lib.mkOverride 500 "100ms";
      RestartSteps = lib.mkOverride 500 9;
    };
    after = [
      "docker-network-all-in-one_default.service"
    ];
    requires = [
      "docker-network-all-in-one_default.service"
    ];
    partOf = [
      "docker-compose-all-in-one-root.target"
    ];
    wantedBy = [
      "docker-compose-all-in-one-root.target"
    ];
    unitConfig.RequiresMountsFor = [
      "/var/garuda/docker-compose-runner/all-in-one/wikijs/assets"
    ];
  };

  # Networks
  systemd.services."docker-network-all-in-one_default" = {
    path = [ pkgs.docker ];
    serviceConfig = {
      Type = "oneshot";
      RemainAfterExit = true;
      ExecStop = "docker network rm -f all-in-one_default";
    };
    script = ''
      docker network inspect all-in-one_default || docker network create all-in-one_default
    '';
    partOf = [ "docker-compose-all-in-one-root.target" ];
    wantedBy = [ "docker-compose-all-in-one-root.target" ];
  };

  # Volumes
  systemd.services."docker-volume-nextcloud_aio_mastercontainer" = {
    path = [ pkgs.docker ];
    serviceConfig = {
      Type = "oneshot";
      RemainAfterExit = true;
    };
    script = ''
      docker volume inspect nextcloud_aio_mastercontainer || docker volume create nextcloud_aio_mastercontainer
    '';
    partOf = [ "docker-compose-all-in-one-root.target" ];
    wantedBy = [ "docker-compose-all-in-one-root.target" ];
  };

  # Root service
  # When started, this will automatically create all resources and start
  # the containers. When stopped, this will teardown all resources.
  systemd.targets."docker-compose-all-in-one-root" = {
    unitConfig = {
      Description = "Root target generated by compose2nix.";
    };
    wantedBy = [ "multi-user.target" ];
  };
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docker-proxied"><a class="header" href="#docker-proxied">docker-proxied</a></h1>
<h2 id="general-2"><a class="header" href="#general-2">General</a></h2>
<p>Here, all of the Docker containers that need to have proxied outgoing requests are being deployed.</p>
<h2 id="nix-expression-2"><a class="header" href="#nix-expression-2">Nix expression</a></h2>
<pre><code class="language-nix">{ pkgs
, sources
, ...
}: {
  imports = sources.defaultModules ++ [
    ../modules
    ./docker-proxied/docker-compose.nix
  ];

  # Let Docker use squid as outgoig proxy
  # Fails to pull images if *.docker.io is not excluded from proxy
  systemd.services.docker = {
    environment = {
      HTTPS_PROXY = "http://10.0.5.1:3128";
      HTTP_PROXY = "http://10.0.5.1:3128";
      NO_PROXY = "localhost,127.0.0.1,*.docker.io,ghcr.io";
    };
  };

  # This is another workaround for the Docker not restarting the container
  systemd.services.check-whoogle = {
    description = "Check whether Whoogle crashed again";
    serviceConfig = {
      ExecStart = pkgs.writeShellScript "execstart" ''
        if ! ${pkgs.curl}/bin/curl -m 10 -s http://localhost:5000/ &gt; /dev/null; then
          ${pkgs.docker}/bin/docker restart whoogle
        fi
      '';
      Restart = "on-failure";
      RestartSec = "30";
    };
    wantedBy = [ "multi-user.target" ];
  };
  systemd.timers.check-whoogle = {
    description = "Check whether Whoogle crashed again";
    timerConfig.OnCalendar = [ "*:0/15" ];
    wantedBy = [ "timers.target" ];
  };

  system.stateVersion = "23.05";
}
</code></pre>
<h3 id="docker-containers-2"><a class="header" href="#docker-containers-2">Docker containers</a></h3>
<pre><code class="language-nix"># Auto-generated using compose2nix v0.2.2-pre.
{ pkgs, lib, ... }:

{
  # Runtime
  virtualisation.docker = {
    enable = true;
    autoPrune.enable = true;
  };
  virtualisation.oci-containers.backend = "docker";

  # Containers
  virtualisation.oci-containers.containers."librey" = {
    image = "ghcr.io/ahwxorg/librey:latest";
    environment = {
      "CONFIG_CACHE_TIME" = "20";
      "CONFIG_DISABLE_BITTORRENT_SEARCH" = "false";
      "CONFIG_GOOGLE_DOMAIN" = "com";
      "CONFIG_HIDDEN_SERVICE_SEARCH" = "true";
      "CONFIG_INSTANCE_FALLBACK" = "true";
      "CONFIG_INVIDIOUS_INSTANCE" = "https://invidious.snopyta.org";
      "CONFIG_LANGUAGE" = "en";
      "CONFIG_NUMBER_OF_RESULTS" = "10";
      "CONFIG_RATE_LIMIT_COOLDOWN" = "25";
      "CONFIG_TEXT_SEARCH_ENGINE" = "google";
    };
    ports = [
      "8081:8080/tcp"
    ];
    log-driver = "journald";
    extraOptions = [
      "--network-alias=librey"
      "--network=proxied_default"
    ];
  };
  systemd.services."docker-librey" = {
    serviceConfig = {
      Restart = lib.mkOverride 500 "always";
      RestartMaxDelaySec = lib.mkOverride 500 "1m";
      RestartSec = lib.mkOverride 500 "100ms";
      RestartSteps = lib.mkOverride 500 9;
    };
    after = [
      "docker-network-proxied_default.service"
    ];
    requires = [
      "docker-network-proxied_default.service"
    ];
    partOf = [
      "docker-compose-proxied-root.target"
    ];
    wantedBy = [
      "docker-compose-proxied-root.target"
    ];
  };
  virtualisation.oci-containers.containers."lingva" = {
    image = "thedaviddelta/lingva-translate:latest";
    environment = {
      "DARK_THEME" = "true";
      "DEFAULT_SOURCE_LANG" = "auto";
      "DEFAULT_TARGET_LANG" = "en";
      "HTTPS_PROXY" = "http://10.0.5.1:3128";
      "HTTP_PROXY" = "http://10.0.5.1:3128";
      "SITE_DOMAIN" = "lingva.garudalinux.org";
    };
    ports = [
      "3002:3000/tcp"
    ];
    log-driver = "journald";
    extraOptions = [
      "--network-alias=lingva"
      "--network=proxied_default"
    ];
  };
  systemd.services."docker-lingva" = {
    serviceConfig = {
      Restart = lib.mkOverride 500 "always";
      RestartMaxDelaySec = lib.mkOverride 500 "1m";
      RestartSec = lib.mkOverride 500 "100ms";
      RestartSteps = lib.mkOverride 500 9;
    };
    after = [
      "docker-network-proxied_default.service"
    ];
    requires = [
      "docker-network-proxied_default.service"
    ];
    partOf = [
      "docker-compose-proxied-root.target"
    ];
    wantedBy = [
      "docker-compose-proxied-root.target"
    ];
  };
  virtualisation.oci-containers.containers."redlib" = {
    image = "quay.io/redlib/redlib:latest";
    environment = {
      "REDLIB_BANNER_" = "Garuda's Redlib";
      "REDLIB_DEFAULT_AUTOPLAY_VIDEOS" = "true";
      "REDLIB_DEFAULT_BLUR_NSFW" = "true";
      "REDLIB_DEFAULT_COMMENT_SORT" = "confidence";
      "REDLIB_DEFAULT_DISABLE_VISIT_REDDIT_CONFIRMATION" = "false";
      "REDLIB_DEFAULT_FIXED_NAVBAR" = "true";
      "REDLIB_DEFAULT_FRONT_PAGE" = "popular";
      "REDLIB_DEFAULT_HIDE_AWARDS" = "true";
      "REDLIB_DEFAULT_HIDE_HLS_NOTIFICATION=" = "true";
      "REDLIB_DEFAULT_HIDE_SCORE" = "false";
      "REDLIB_DEFAULT_LAYOUT" = "card";
      "REDLIB_DEFAULT_POST_SORT" = "hot";
      "REDLIB_DEFAULT_SHOW_NSFW" = "false";
      "REDLIB_DEFAULT_THEME" = "dracula";
      "REDLIB_DEFAULT_USE_HLS" = "true";
      "REDLIB_DEFAULT_WIDE" = "false";
      "REDLIB_PUSHSHIFT_FRONTEND" = "undelete.pullpush.io";
      "REDLIB_ROBOTS_DISABLE_INDEXING" = "true";
      "REDLIB_SFW_ONLY" = "false";
    };
    ports = [
      "8082:8080/tcp"
    ];
    user = "nobody";
    log-driver = "journald";
    extraOptions = [
      "--cap-drop=ALL"
      "--health-cmd=[\"wget\",\"--spider\",\"-q\",\"--tries=1\",\"http://localhost:8082/settings\"]"
      "--health-interval=5m0s"
      "--health-timeout=3s"
      "--network-alias=redlib"
      "--network=proxied_default"
      "--security-opt=no-new-privileges:true"
    ];
  };
  systemd.services."docker-redlib" = {
    serviceConfig = {
      Restart = lib.mkOverride 500 "always";
      RestartMaxDelaySec = lib.mkOverride 500 "1m";
      RestartSec = lib.mkOverride 500 "100ms";
      RestartSteps = lib.mkOverride 500 9;
    };
    after = [
      "docker-network-proxied_default.service"
    ];
    requires = [
      "docker-network-proxied_default.service"
    ];
    partOf = [
      "docker-compose-proxied-root.target"
    ];
    wantedBy = [
      "docker-compose-proxied-root.target"
    ];
  };
  virtualisation.oci-containers.containers."searx" = {
    image = "searxng/searxng:latest";
    environment = {
      "BASE_URL" = "https://searx.garudalinux.org/";
      "BIND_ADDRESS" = "0.0.0.0:8080";
      "HTTPS_PROXY" = "http://10.0.5.1:3128";
      "HTTP_PROXY" = "http://10.0.5.1:3128";
      "INSTANCE_NAME" = "Garuda's SearxNG";
      "NO_PROXY" = "*.garudalinux.org";
    };
    volumes = [
      "/var/garuda/docker-compose-runner/proxied/searxng:/etc/searxng:rw"
    ];
    ports = [
      "8080:8080/tcp"
    ];
    log-driver = "journald";
    extraOptions = [
      "--cap-add=CHOWN"
      "--cap-add=DAC_OVERRIDE"
      "--cap-add=SETGID"
      "--cap-add=SETUID"
      "--cap-drop=ALL"
      "--network-alias=searx"
      "--network=proxied_default"
    ];
    environmentFiles = [
      "/var/garuda/secrets/docker-compose/proxied.env"
    ];
  };
  systemd.services."docker-searx" = {
    serviceConfig = {
      Restart = lib.mkOverride 500 "always";
      RestartMaxDelaySec = lib.mkOverride 500 "1m";
      RestartSec = lib.mkOverride 500 "100ms";
      RestartSteps = lib.mkOverride 500 9;
    };
    after = [
      "docker-network-proxied_default.service"
    ];
    requires = [
      "docker-network-proxied_default.service"
    ];
    partOf = [
      "docker-compose-proxied-root.target"
    ];
    wantedBy = [
      "docker-compose-proxied-root.target"
    ];
    unitConfig.RequiresMountsFor = [
      "/var/garuda/docker-compose-runner/proxied/searxng"
    ];
  };
  virtualisation.oci-containers.containers."watchtower" = {
    image = "containrrr/watchtower:1.7.1";
    volumes = [
      "/var/run/docker.sock:/var/run/docker.sock:rw"
    ];
    cmd = [ "--cleanup" "searx" "lingva" "whoogle" "librey" ];
    log-driver = "journald";
    extraOptions = [
      "--network-alias=watchtower"
      "--network=proxied_default"
    ];
  };
  systemd.services."docker-watchtower" = {
    serviceConfig = {
      Restart = lib.mkOverride 500 "always";
      RestartMaxDelaySec = lib.mkOverride 500 "1m";
      RestartSec = lib.mkOverride 500 "100ms";
      RestartSteps = lib.mkOverride 500 9;
    };
    after = [
      "docker-network-proxied_default.service"
    ];
    requires = [
      "docker-network-proxied_default.service"
    ];
    partOf = [
      "docker-compose-proxied-root.target"
    ];
    wantedBy = [
      "docker-compose-proxied-root.target"
    ];
    unitConfig.RequiresMountsFor = [
      "/var/run/docker.sock"
    ];
  };
  virtualisation.oci-containers.containers."whoogle" = {
    image = "benbusby/whoogle-search:latest";
    environment = {
      "WHOOGLE_AUTOCOMPLETE" = "1";
      "WHOOGLE_CONFIG_LANGUAGE" = "lang_en";
      "WHOOGLE_CONFIG_NEW_TAB" = "1";
      "WHOOGLE_CONFIG_SEARCH_LANGUAGE" = "lang_en";
      "WHOOGLE_CONFIG_STYLE" = ":root {--whoogle-logo: #4c4f69;--whoogle-page-bg: #eff1f5;--whoogle-element-bg: #bcc0cc;--whoogle-text: #4c4f69;--whoogle-contrast-text: #5c5f77;--whoogle-secondary-text: #6c6f85;
  --whoogle-result-bg: #ccd0da;--whoogle-result-title: #7287fd;--whoogle-result-url: #dc8a78;--whoogle-result-visited: #e64553;--whoogle-dark-logo: #cdd6f4;
  --whoogle-dark-page-bg: #1e1e2e;--whoogle-dark-element-bg: #45475a;--whoogle-dark-text: #cdd6f4;--whoogle-dark-contrast-text: #bac2de;--whoogle-dark-secondary-text: #a6adc8;
  --whoogle-dark-result-bg: #313244;--whoogle-dark-result-title: #b4befe;--whoogle-dark-result-url: #f5e0dc;--whoogle-dark-result-visited: #eba0ac;}
  #whoogle-w {fill: #89b4fa;} #whoogle-h {fill: #f38ba8;}#whoogle-o-1 {fill: #f9e2af;}#whoogle-o-2 {fill: #89b4fa;}#whoogle-g {fill: #a6e3a1;}#whoogle-l {fill: #f38ba8;}
  #whoogle-e {fill: #f9e2af;}
  ";
      "WHOOGLE_CONFIG_THEME" = "dark";
      "WHOOGLE_CONFIG_URL" = "https://search.garudalinux.org";
      "WHOOGLE_CONFIG_VIEW_IMAGE" = "1";
      "WHOOGLE_RESULTS_PER_PAGE" = "15";
    };
    volumes = [
      "/var/garuda/docker-compose-runner/proxied/whoogle:/config:rw"
    ];
    ports = [
      "5000:5000/tcp"
    ];
    user = "whoogle";
    log-driver = "journald";
    extraOptions = [
      "--cap-drop=ALL"
      "--network-alias=whoogle"
      "--network=proxied_default"
      "--security-opt=no-new-privileges"
    ];
  };
  systemd.services."docker-whoogle" = {
    serviceConfig = {
      Restart = lib.mkOverride 500 "always";
      RestartMaxDelaySec = lib.mkOverride 500 "1m";
      RestartSec = lib.mkOverride 500 "100ms";
      RestartSteps = lib.mkOverride 500 9;
    };
    after = [
      "docker-network-proxied_default.service"
    ];
    requires = [
      "docker-network-proxied_default.service"
    ];
    partOf = [
      "docker-compose-proxied-root.target"
    ];
    wantedBy = [
      "docker-compose-proxied-root.target"
    ];
    unitConfig.RequiresMountsFor = [
      "/var/garuda/docker-compose-runner/proxied/whoogle"
    ];
  };

  # Networks
  systemd.services."docker-network-proxied_default" = {
    path = [ pkgs.docker ];
    serviceConfig = {
      Type = "oneshot";
      RemainAfterExit = true;
      ExecStop = "docker network rm -f proxied_default";
    };
    script = ''
      docker network inspect proxied_default || docker network create proxied_default
    '';
    partOf = [ "docker-compose-proxied-root.target" ];
    wantedBy = [ "docker-compose-proxied-root.target" ];
  };

  # Root service
  # When started, this will automatically create all resources and start
  # the containers. When stopped, this will teardown all resources.
  systemd.targets."docker-compose-proxied-root" = {
    unitConfig = {
      Description = "Root target generated by compose2nix.";
    };
    wantedBy = [ "multi-user.target" ];
  };
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forum"><a class="header" href="#forum">forum</a></h1>
<h2 id="general-3"><a class="header" href="#general-3">General</a></h2>
<p>In here, we only have Docker set up and use the traditional way of installing Discourse to <code>/var/discourse</code>. Since own scripts are provided to handle the container, not much is to be seen here.</p>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<ul>
<li><a href="https://github.com/discourse/discourse_docker">Discourse Docker</a></li>
</ul>
<h2 id="nix-expression-3"><a class="header" href="#nix-expression-3">Nix expression</a></h2>
<pre><code class="language-nix">{ sources, ... }: {
  imports = sources.defaultModules ++ [ ../modules ];

  # Enable Docker since we use the official Docker image in /var/discourse
  virtualisation.docker.enable = true;

  # Open required port
  networking.firewall.allowedTCPPorts = [ 80 ];

  system.stateVersion = "23.05";
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="github-runner"><a class="header" href="#github-runner">github-runner</a></h1>
<h2 id="general-4"><a class="header" href="#general-4">General</a></h2>
<p>With this container, we provide a GitHub runner as well as (more recently), a GitLab runner. This container does <strong>not</strong> have the regular Garuda configurations because it is considered untrusted.
Access needs to happen by running <code>nixos-container root-login</code> on <code>immortalis</code> (<a href="http://docs.garudalinux.net/hosts/immortalis.html#connecting-to-the-server">click me</a>).</p>
<h2 id="nix-expression-4"><a class="header" href="#nix-expression-4">Nix expression</a></h2>
<pre><code class="language-nix">{ keys
, ...
}: {
  # No default modules, untrusted container!
  # imports = sources.defaultModules ++ [
  #   ./garuda/garuda.nix
  # ];

  imports = [
    ../modules/hardening.nix
    ../modules/motd.nix
    ./github-runner/github-compose.nix
    ./github-runner/gitlab-compose.nix
  ];

  # Common Docker configurations
  virtualisation.docker = {
    autoPrune.enable = true;
    autoPrune.flags = [ "-a" ];
  };

  # Enable SSH
  services.openssh.enable = true;

  # No custom users - only Pedro and root via nixos-container root-login
  users = {
    allowNoPasswordLogin = true;
    mutableUsers = false;
    users.pedrohlc = {
      home = "/home/pedrohlc";
      isNormalUser = true;
      openssh.authorizedKeys.keyFiles = [ keys.pedrohlc ];
    };
  };

  # Make Pedro god here
  nix.settings.trusted-users = [ "pedrohlc" ];
  security.sudo.extraRules = [
    {
      users = [ "pedrohlc" ];
      commands = [
        {
          command = "ALL";
          options = [ "NOPASSWD" ];
        }
      ];
    }
  ];

  # OOM prevention
  systemd.oomd = {
    enable = true; # This is actually the default, anyways...
    enableSystemSlice = true;
    enableUserSlices = true;
  };

  networking.firewall = {
    extraCommands = ''
      iptables -t nat -A PREROUTING -p tcp -d 172.17.0.1 --dport 3128 -j DNAT --to-destination 10.0.5.1:3128
      iptables -t nat -A POSTROUTING -p tcp -d 172.17.0.1 --dport 3128 -j SNAT --to-source 10.0.5.130
    '';
    extraStopCommands = ''
      iptables -t nat -D PREROUTING -p tcp -d 10.130.0.1 --dport 3128 -j DNAT --to-destination 10.0.5.1:3128
      iptables -t nat -D POSTROUTING -p tcp -d 10.0.5.1 --dport 3128 -j SNAT --to-source 10.0.5.130
    '';
  };

  system.stateVersion = "23.05";
}
</code></pre>
<h3 id="docker-containers-github"><a class="header" href="#docker-containers-github">Docker containers (GitHub)</a></h3>
<pre><code class="language-nix"># Auto-generated using compose2nix v0.2.2-pre.
{ pkgs, lib, ... }:

{
  # Runtime
  virtualisation.docker = {
    enable = true;
    autoPrune.enable = true;
  };
  virtualisation.oci-containers.backend = "docker";

  # Containers
  virtualisation.oci-containers.containers."github-runner" = {
    image = "myoung34/github-runner:2.318.0";
    environment = {
      "EPHEMERAL" = "true";
      "LABELS" = "nyxbuilder";
      "ORG_NAME" = "chaotic-cx";
      "RUNNER_NAME" = "immortalis";
      "RUNNER_SCOPE" = "org";
      "RUNNER_WORKDIR" = "/tmp/runner/work";
    };
    volumes = [
      "/tmp/runner:/tmp/runner:rw"
    ];
    log-driver = "journald";
    extraOptions = [
      "--network-alias=github-runner"
      "--network=github-runner_default"
      "--privileged"
    ];
    environmentFiles = [
      "/var/garuda/secrets/github-runner.env"
    ];
  };
  systemd.services."docker-github-runner" = {
    serviceConfig = {
      Restart = lib.mkOverride 500 "no";
    };
    after = [
      "docker-network-github-runner_default.service"
    ];
    requires = [
      "docker-network-github-runner_default.service"
    ];
    partOf = [
      "docker-compose-github-runner-root.target"
    ];
    wantedBy = [
      "docker-compose-github-runner-root.target"
    ];
    unitConfig.RequiresMountsFor = [
      "/tmp/runner"
    ];
  };

  # Networks
  systemd.services."docker-network-github-runner_default" = {
    path = [ pkgs.docker ];
    serviceConfig = {
      Type = "oneshot";
      RemainAfterExit = true;
      ExecStop = "docker network rm -f github-runner_default";
    };
    script = ''
      docker network inspect github-runner_default || docker network create github-runner_default
    '';
    partOf = [ "docker-compose-github-runner-root.target" ];
    wantedBy = [ "docker-compose-github-runner-root.target" ];
  };

  # Root service
  # When started, this will automatically create all resources and start
  # the containers. When stopped, this will teardown all resources.
  systemd.targets."docker-compose-github-runner-root" = {
    unitConfig = {
      Description = "Root target generated by compose2nix.";
    };
    wantedBy = [ "multi-user.target" ];
  };
}

### Docker containers (GitLab)

```nix
# Auto-generated using compose2nix v0.2.2-pre.
{ pkgs, lib, ... }:

{
  # Runtime
  virtualisation.docker = {
    enable = true;
    autoPrune.enable = true;
  };
  virtualisation.oci-containers.backend = "docker";

  # Containers
  virtualisation.oci-containers.containers."gitlab-runner-chaotic" = {
    image = "gitlab/gitlab-runner:alpine";
    volumes = [
      "/etc/gitlab-runner/chaotic:/etc/gitlab-runner:rw"
      "/var/run/docker.sock:/var/run/docker.sock:rw"
    ];
    log-driver = "journald";
    extraOptions = [
      "--network-alias=gitlab-runner-chaotic"
      "--network=gitlab-runner_default"
    ];
  };
  systemd.services."docker-gitlab-runner-chaotic" = {
    serviceConfig = {
      Restart = lib.mkOverride 500 "no";
    };
    after = [
      "docker-network-gitlab-runner_default.service"
    ];
    requires = [
      "docker-network-gitlab-runner_default.service"
    ];
    partOf = [
      "docker-compose-gitlab-runner-root.target"
    ];
    wantedBy = [
      "docker-compose-gitlab-runner-root.target"
    ];
    unitConfig.RequiresMountsFor = [
      "/etc/gitlab-runner/chaotic"
      "/var/run/docker.sock"
    ];
  };
  virtualisation.oci-containers.containers."gitlab-runner-dind" = {
    image = "gitlab/gitlab-runner:alpine";
    volumes = [
      "/etc/gitlab-runner/dind:/etc/gitlab-runner:rw"
      "/var/run/docker.sock:/var/run/docker.sock:rw"
    ];
    log-driver = "journald";
    extraOptions = [
      "--network-alias=gitlab-runner-dind"
      "--network=gitlab-runner_default"
    ];
  };
  systemd.services."docker-gitlab-runner-dind" = {
    serviceConfig = {
      Restart = lib.mkOverride 500 "no";
    };
    after = [
      "docker-network-gitlab-runner_default.service"
    ];
    requires = [
      "docker-network-gitlab-runner_default.service"
    ];
    partOf = [
      "docker-compose-gitlab-runner-root.target"
    ];
    wantedBy = [
      "docker-compose-gitlab-runner-root.target"
    ];
    unitConfig.RequiresMountsFor = [
      "/etc/gitlab-runner/dind"
      "/var/run/docker.sock"
    ];
  };
  virtualisation.oci-containers.containers."gitlab-runner-garuda" = {
    image = "gitlab/gitlab-runner:alpine";
    volumes = [
      "/etc/gitlab-runner:/etc/gitlab-runner:rw"
      "/var/run/docker.sock:/var/run/docker.sock:rw"
    ];
    log-driver = "journald";
    extraOptions = [
      "--network-alias=gitlab-runner-garuda"
      "--network=gitlab-runner_default"
    ];
  };
  systemd.services."docker-gitlab-runner-garuda" = {
    serviceConfig = {
      Restart = lib.mkOverride 500 "no";
    };
    after = [
      "docker-network-gitlab-runner_default.service"
    ];
    requires = [
      "docker-network-gitlab-runner_default.service"
    ];
    partOf = [
      "docker-compose-gitlab-runner-root.target"
    ];
    wantedBy = [
      "docker-compose-gitlab-runner-root.target"
    ];
    unitConfig.RequiresMountsFor = [
      "/etc/gitlab-runner"
      "/var/run/docker.sock"
    ];
  };
  virtualisation.oci-containers.containers."watchtower" = {
    image = "containrrr/watchtower:1.7.1";
    volumes = [
      "/var/run/docker.sock:/var/run/docker.sock:rw"
    ];
    cmd = [ "--cleanup" "gitlab-runner-chaotic" "gitlab-runner-garuda" "gitlab-runner-dind" ];
    log-driver = "journald";
    extraOptions = [
      "--network-alias=watchtower"
      "--network=gitlab-runner_default"
    ];
  };
  systemd.services."docker-watchtower" = {
    serviceConfig = {
      Restart = lib.mkOverride 500 "always";
      RestartMaxDelaySec = lib.mkOverride 500 "1m";
      RestartSec = lib.mkOverride 500 "100ms";
      RestartSteps = lib.mkOverride 500 9;
    };
    after = [
      "docker-network-gitlab-runner_default.service"
    ];
    requires = [
      "docker-network-gitlab-runner_default.service"
    ];
    partOf = [
      "docker-compose-gitlab-runner-root.target"
    ];
    wantedBy = [
      "docker-compose-gitlab-runner-root.target"
    ];
    unitConfig.RequiresMountsFor = [
      "/var/run/docker.sock"
    ];
  };

  # Networks
  systemd.services."docker-network-gitlab-runner_default" = {
    path = [ pkgs.docker ];
    serviceConfig = {
      Type = "oneshot";
      RemainAfterExit = true;
      ExecStop = "docker network rm -f gitlab-runner_default";
    };
    script = ''
      docker network inspect gitlab-runner_default || docker network create gitlab-runner_default
    '';
    partOf = [ "docker-compose-gitlab-runner-root.target" ];
    wantedBy = [ "docker-compose-gitlab-runner-root.target" ];
  };

  # Root service
  # When started, this will automatically create all resources and start
  # the containers. When stopped, this will teardown all resources.
  systemd.targets."docker-compose-gitlab-runner-root" = {
    unitConfig = {
      Description = "Root target generated by compose2nix.";
    };
    wantedBy = [ "multi-user.target" ];
  };
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lemmy"><a class="header" href="#lemmy">lemmy</a></h1>
<h2 id="general-5"><a class="header" href="#general-5">General</a></h2>
<p>This container provides our Lemmy instance</p>
<h2 id="nix-expression-5"><a class="header" href="#nix-expression-5">Nix expression</a></h2>
<pre><code class="language-nix">{ garuda-lib
, sources
, ...
}: {
  imports = sources.defaultModules ++ [ ../modules ];

  # Our Lemmy instance
  services.lemmy = {
    database.uri = "postgresql://lemmy:${garuda-lib.secrets.lemmy.database}@10.0.5.50/lemmy";
    enable = true;
    settings = {
      hostname = "lemmy.garudalinux.org";
      email = {
        smtp_server = "mail.garudalinux.net:587";
        smtp_login = "noreply@garudalinux.org";
        inherit (garuda-lib.secrets.lemmy) smtp_password;
        smtp_from_address = "noreply@garudalinux.org";
        tls_type = "starttls";
      };
    };
  };

  services.nginx = {
    enable = true;
    httpConfig = ''
      map "$request_method:$http_accept" $proxpass {
          # If no explicit matches exists below, send traffic to lemmy-ui
          default "http://lemmy-ui";

          # GET/HEAD requests that accepts ActivityPub or Linked Data JSON should go to lemmy
          # "~^(?:GET|HEAD):.*?application\/(?:activity|ld)\+json" "http://lemmy";

          # All non-GET/HEAD requests should go to lemmy
          "~^(?!(GET|HEAD)).*:" "http://lemmy";
      }

      upstream lemmy {
        server "127.0.0.1:8536";
      }
      upstream lemmy-ui {
        server "127.0.0.1:1234";
      }
      
      server {
          listen 80;
          
          server_name lemmy.garudalinux.org;
          server_tokens off;

          gzip on;
          gzip_types text/css application/javascript image/svg+xml;
          gzip_vary on;

          client_max_body_size 25M;

          add_header X-Frame-Options SAMEORIGIN;
          add_header X-Content-Type-Options nosniff;
          add_header X-XSS-Protection "1; mode=block";

          real_ip_header X-Real-IP;
          set_real_ip_from 10.0.5.10;

          # frontend general requests
          location / {
              proxy_pass $proxpass;
              rewrite ^(.+)/+$ $1 permanent;
              proxy_set_header X-Real-IP $remote_addr;
              proxy_set_header Host $host;
          }

          # backend
          location ~ ^/(api|pictrs|feeds|nodeinfo|.well-known) {
              proxy_pass "http://lemmy";
              proxy_http_version 1.1;
              proxy_set_header Upgrade $http_upgrade;
              proxy_set_header Connection "upgrade";
              proxy_set_header X-Real-IP $remote_addr;
              proxy_set_header Host $host;
          }
      }
    '';
  };

  system.stateVersion = "23.05";
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mastodon"><a class="header" href="#mastodon">mastodon</a></h1>
<h2 id="general-6"><a class="header" href="#general-6">General</a></h2>
<p>This container provides our Mastodon instance.</p>
<h2 id="nix-expression-6"><a class="header" href="#nix-expression-6">Nix expression</a></h2>
<pre><code class="language-nix">{ lib
, pkgs
, sources
, garuda-lib
, ...
}: {
  imports = sources.defaultModules ++ [ ../modules ];

  # Our Mastodon
  services.mastodon = {
    configureNginx = true;
    database = {
      createLocally = false;
      host = "10.0.5.50";
      name = "mastodon";
      passwordFile = "/var/lib/mastodon/secrets/db-password";
      user = "mastodon";
    };
    enable = true;
    extraConfig = {
      "LOCAL_DOMAIN" = "garudalinux.org";
      "SMTP_DOMAIN" = "social.garudalinux.org";
      "WEB_DOMAIN" = "social.garudalinux.org";
    };
    extraEnvFiles = [ "/var/lib/mastodon/secrets/env" ];
    localDomain = "social.garudalinux.org";
    mediaAutoRemove.enable = false;
    smtp = {
      authenticate = true;
      fromAddress = "noreply@garudalinux.org";
      host = "mail.garudalinux.net";
      passwordFile = "/var/lib/mastodon/secrets/smtp-password";
      port = 587;
      user = "noreply@garudalinux.org";
    };
    streamingProcesses = 4;
  };

  # Run daily cleanup of statuses and media of Mastodon
  systemd.services.mastodon-media-cleanup = {
    description = "Run daily cleanup of statuses and media of Mastodon";
    serviceConfig = {
      ExecStart = pkgs.writeShellScript "execstart" ''
        set -e
        /run/current-system/sw/bin/mastodon-tootctl media remove --days=30
        /run/current-system/sw/bin/mastodon-tootctl statuses remove --days=30
      '';
      Path = [ pkgs.mastodon ];
      Restart = "on-failure";
      RestartSec = "30";
    };
    wantedBy = [ "multi-user.target" ];
  };
  systemd.timers.mastodon-media-cleanup = {
    description = "Monthly cleanup of statuses and media of Mastodon";
    timerConfig.OnCalendar = [ "monthly" ];
    wantedBy = [ "timers.target" ];
  };

  # Scan for orphaned media mo
  systemd.services.mastodon-orphan-cleanup = {
    description = "Run weekly cleanup of orphaned media of Mastodon";
    serviceConfig = {
      ExecStart = pkgs.writeShellScript "execstart" ''
        set -e
        /run/current-system/sw/bin/mastodon-tootctl media remove --days=7
        /run/current-system/sw/bin/mastodon-tootctl statuses remove --days=7
      '';
      Path = [ pkgs.mastodon ];
      Restart = "on-failure";
      RestartSec = "30";
    };
    wantedBy = [ "multi-user.target" ];
  };
  systemd.timers.mastodon-orphan-cleanup = {
    description = "Run weekly cleanup of orphaned media of Mastodon";
    timerConfig.OnCalendar = [ "weekly" ];
    wantedBy = [ "timers.target" ];
  };

  services.nginx = {
    virtualHosts."social.garudalinux.org" = {
      enableACME = lib.mkForce false;
      useACMEHost = "garudalinux.org";
      extraConfig = ''
        ${garuda-lib.nginxReverseProxySettings}
        real_ip_header X-Real-IP;
        set_real_ip_from 10.0.5.10;
      '';
      locations = {
        "@proxy" = {
          proxyWebsockets = lib.mkForce false;
        };
        "/api/v1/streaming/" = {
          proxyWebsockets = lib.mkForce false;
        };
      };
    };
  };

  system.stateVersion = "23.05";
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mongodb"><a class="header" href="#mongodb">mongodb</a></h1>
<h2 id="general-7"><a class="header" href="#general-7">General</a></h2>
<p>This container contains our MongoDB instance, which is primarily used for storing Chaotic-AUR router metrics.</p>
<p>The instance requires the use of TLS, but can be accessed without presenting a valid client certificate,
so that the Heroku instance the router runs on can access it easier.</p>
<h2 id="nix-expression-7"><a class="header" href="#nix-expression-7">Nix expression</a></h2>
<pre><code class="language-nix">{ pkgs
, sources
, ...
}:
{
  imports = sources.defaultModules ++ [ ../modules ];

  # Our MongoDB database
  services.mongodb = {
    enable = true;
    bind_ip = "10.0.5.60";
    enableAuth = true;
    extraConfig = ''
      net.tls.mode: requireTLS
      net.tls.certificateKeyFile: /etc/ssl/mongodb/mongodb.pem
      net.tls.CAFile: /etc/ssl/mongodb/ca.crt
      net.tls.allowConnectionsWithoutCertificates: true
    '';
    quiet = true;
    initialRootPassword = "yupHasAlreadyBeenChanged";
  };

  # MongoDB port is being forwarded to this container
  networking.firewall = { allowedTCPPorts = [ 27017 ]; };

  # Local management
  environment.systemPackages = [ pkgs.mongosh ];

  system.stateVersion = "24.05";
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="postgres"><a class="header" href="#postgres">postgres</a></h1>
<h2 id="general-8"><a class="header" href="#general-8">General</a></h2>
<p>This container houses our Postgres database. Multiple services access it:</p>
<ul>
<li>Lemmy</li>
<li>Mastodon</li>
<li>Matrix</li>
<li>Matrix bridges</li>
<li>WikiJs</li>
</ul>
<h2 id="nix-expression-8"><a class="header" href="#nix-expression-8">Nix expression</a></h2>
<pre><code class="language-nix">{ garuda-lib
, pkgs
, sources
, config
, lib
, ...
}:
let
  server_config = pkgs.writeText "server-config" ''
    {
      "Servers": {
        "1": {
          "Name": "Main",
          "Group": "Garuda",
          "Username": "pgadmin",
          "Host": "/var/run/postgresql",
          "Port": 5432,
          "SSLMode": "prefer",
          "MaintenanceDB": "postgres",
          "PassFile": "/dev/null",
          "Shared": true,
          "SharedUsername": "pgadmin"
        }
      }
    }
  '';
in
{
  imports = sources.defaultModules ++ [ ../modules ];

  # Our Postgres database
  services.postgresql = {
    enable = true;
    ensureDatabases = [
      "lemmy"
      "matrix-discord"
      "matrix-irc"
      "matrix-telegram"
      "mastodon"
      "synapse"
      "wikijs"
    ];
    ensureUsers = [
      {
        name = "lemmy";
        ensureDBOwnership = true;
      }
      {
        name = "mastodon";
        ensureDBOwnership = true;
      }
      {
        name = "matrix-bridges";
      }
      {
        name = "synapse";
        ensureDBOwnership = true;
      }
      {
        name = "wikijs";
        ensureDBOwnership = true;
      }
      {
        name = "pgadmin";
        ensureClauses.superuser = true;
      }
    ];
    initialScript = pkgs.writeText "backend-initScript" ''
      CREATE USER netdata;
      GRANT pg_monitor TO netdata;

      # After 23.11, ensurePermissions got deprecated
      GRANT ALL PRIVILEGES ON DATABASE matrix-bridges TO matrix-discord;
      GRANT ALL PRIVILEGES ON DATABASE matrix-bridges TO matrix-irc;
      GRANT ALL PRIVILEGES ON DATABASE matrix-bridges TO matrix-telegram;
    '';
    authentication = "host all all 10.0.5.0/24 md5";
    # We don't need to worry about different interfaces, because the only interface 
    # available is eth0, which is fully isolated
    enableTCPIP = true;
  };

  # Regular backups for our database (every 6h)
  services.postgresqlBackup = {
    compression = "zstd";
    enable = true;
    location = "/var/garuda/backups/postgres";
  };

  # Run daily synapse state compressor on Matrix database
  systemd.services.synapse_auto_compressor = {
    description = "Run synapse state compressor on Matrix db";
    serviceConfig = {
      ExecStart = pkgs.writeShellScript "execstart" ''
        set -e
        ${pkgs.matrix-synapse-tools.rust-synapse-compress-state}/bin/synapse_auto_compressor \
          -p postgresql://${garuda-lib.secrets.matrix.db_string}@10.0.5.50/synapse -c 500 -n 100
      '';
      Restart = "on-failure";
      RestartSec = "30";
    };
    wantedBy = [ "multi-user.target" ];
  };
  systemd.timers.synapse_auto_compressor = {
    description = "Run synapse state compressor on Matrix db";
    timerConfig.OnCalendar = [ "daily" ];
    wantedBy = [ "timers.target" ];
  };

  services.pgadmin = {
    enable = true;
    initialEmail = "team@garudalinux.org";
    initialPasswordFile = garuda-lib.secrets.pgadmin_password;
    openFirewall = true;
    settings = {
      FIXED_BINARY_PATHS = {
        "pg" = "${config.services.postgresql.package}/bin";
      };
      SUPPORT_SSH_TUNNEL = false;
      AUTHENTICATION_SOURCES = [ "webserver" ];
      WEBSERVER_REMOTE_USER = "X-Forwarded-User";
      MASTER_PASSWORD_REQUIRED = false;
    };
  };

  systemd.services.pgadmin = {
    preStart = lib.mkAfter ''
      EMAIL=${lib.escapeShellArg config.services.pgadmin.initialEmail}
      FILE=${lib.escapeShellArg server_config}
      ${config.services.pgadmin.package}/bin/pgadmin4-cli load-servers "$FILE" --user "$EMAIL"
    '';
  };

  # Open up ports for Postgres
  networking.firewall.allowedTCPPorts = [ 5432 ];

  system.stateVersion = "23.05";
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="temeraire"><a class="header" href="#temeraire">temeraire</a></h1>
<h2 id="general-9"><a class="header" href="#general-9">General</a></h2>
<p>This is our package builder, which also serves as the main node for Chaotic-AUR.</p>
<h2 id="nix-expression-9"><a class="header" href="#nix-expression-9">Nix expression</a></h2>
<pre><code class="language-nix">{ config
, garuda-lib
, pkgs
, sources
, ...
}: {
  imports = sources.defaultModules ++ [ ../modules ];

  # This disables HTTPS certificates and forced redirects
  garuda-lib.behind_proxy = true;

  # Enable Chaotic-AUR building
  services.chaotic.enable = true;
  services.chaotic.cluster-name = "garuda-cluster";
  # Let nginx set itself up for this local domain
  services.chaotic.host = "local.chaotic.invalid";
  services.chaotic.extraConfig = ''
    export CAUR_DEPLOY_LABEL="Temeraire 🐉"
    export CAUR_PACKAGER="Garuda Builder &lt;team@garudalinux.org&gt;"
    export CAUR_ROUTINES=/tmp/chaotic/routines
    export CAUR_SIGN_KEY=D6C9442437365605
    export CAUR_SIGN_USER=root
    export CAUR_TELEGRAM_TAG="@dr460nf1r3"
    export CAUR_TYPE=primary
    export CAUR_URL=https://builds.garudalinux.org/repos/chaotic-aur/x86_64
    export REPOCTL_CONFIG=/usr/local/etc/chaotic-repoctl.toml

    export GIT_SSH_COMMAND="ssh -i /var/garuda/secrets/chaotic/interfere_ed25519"
    export HTTPS_PROXY=http://10.0.5.1:3128/
    export HTTP_PROXY=http://10.0.5.1:3128/
    export NO_PROXY=mirror.rackspace.com,cloudflaremirrors.com,github.com,downloads.sentry-cdn.com
  '';
  services.chaotic.db-name = "chaotic-aur";
  services.chaotic.routines = [ "afternoon" "hourly.1" "hourly.2" "morning" "nightly" "tkg-wine" ];

  # Special Syncthing configuration allowing to push to main node
  services.syncthing = {
    enable = true;
    openDefaultPorts = true;
    configDir = config.services.syncthing.dataDir;
    inherit (garuda-lib.secrets.syncthing.esxi-build) cert key;
    overrideFolders = false;
    overrideDevices = false;
    user = "root";
    group = "chaotic_op";
    settings = {
      gui = {
        apikey = "garudalinux";
        insecureSkipHostcheck = true;
        inherit (garuda-lib.secrets.syncthing.esxi-build.credentials) user password;
      };
    };
    guiAddress = "10.0.5.20:8384";
  };

  # Allow systemd-nspawn to create subcgroups (for Chaotic-AUR builders)
  systemd.services.remount-sysfscgroup = {
    description = "Remount cgroup2 to allow systemd-nspawn to create subcgroups";
    wantedBy = [ "multi-user.target" ];
    serviceConfig.Type = "oneshot";
    script = ''
      ${pkgs.mount}/bin/mount -t cgroup2 -o rw,nosuid,nodev,noexec,relatime none /sys/fs/cgroup
    '';
  };

  # Auto reset syncthing stuff
  systemd.services.syncthing-reset = {
    serviceConfig.Type = "oneshot";
    script = ''
      "${pkgs.curl}/bin/curl" -X POST -H "X-API-Key: garudalinux" http://localhost:8384/rest/db/override?folder=${garuda-lib.secrets.syncthing.folders.chaotic-aur}
    '';
  };
  systemd.timers.syncthing-reset = {
    wantedBy = [ "timers.target" ];
    timerConfig.OnCalendar = [ "hourly" ];
  };

  garuda-lib.chaoticUsers = true;

  # Chaotic-AUR builders need to upload their packages
  users.users.ufscar_hpc = {
    extraGroups = [ "chaotic_op" ];
    isNormalUser = true;
    openssh.authorizedKeys.keys = [
      "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFslN7a613H3hztK/yzHE4ZBOJ4448+EN867Y/IDpAfc u726578@c6.cluster.infra.ufscar.br"
    ];
  };
  users.users.catbuilder = {
    extraGroups = [ "chaotic_op" ];
    isNormalUser = true;
    openssh.authorizedKeys.keys = [
      "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDHELhrMFNvxgAYMdzwerszypuvQc3uCFjkR6xCbcQnrcCrueJqTQ4y8WzddwxhRzKbSTQVhPdB5l95IYk7eOtmBmaMp4LAV2osMWDI/x3NyoY5s7YgpW815qNX9Io7VnrFUr0LK7hJ+Uw87nyxGp3zGddPVMUK7PIdJf2GxTxKPryycdLa9QWijfm3YBdN10yBMp6KrfPEnhtmNPMrc3wuBG4+xBoJxNOy0DJdIf2PRwU2CddP0zdDWwlMbGeHGcaJmlAx0u9e1jL8KWB/oyGT1D9q4l+fU8E9nZG+kAFMO1yG25je9bJnYNPMV1gdRT47G3J/B982XYO4G4AiOER0v0M0MN0qWTvIVBG6Vnly81ME91Qao34Lw2QOhZMVFwWz01u8KLLQy/Z2rX7jKyqeUyGXgs5NPmkeJ1vzpSRLXY+5GX5yva8A041Nft7sfKYPFjMsDaxAKVPz7LkKX1dYdiC4c3a/RcCzLKY+Uabjr0QAK4MKwmMW+SNF0QHr9mk= root@Chaotic"
    ];
  };
  users.users.chaotic-dragon = {
    extraGroups = [ "chaotic_op" ];
    isNormalUser = true;
    openssh.authorizedKeys.keys = [
      "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQC0zLuPM4IE4xsxen2XBqWKSQz5CpHONgguOhVuR5rTxRqijiwGro0VR4gPhpmuZjLkms4CJ2YGyjTbjDkh48+wAoiPjdvVqF6kJ9TLkHZabMJfx5chKMCVFcHM+0/F768fF/nRsfusbRO7H2nLGMXJ1eObemiCGg0e8Ccs0XA4PF9bGaDm+4bblNasVyT6PsnaYziyBtwU3fzBVbdQmErw37sjXV9jNsEq3XF9wSaFf/Dfzh9xY1CR1KC7Af84lL1vOj7QL06tEmDO6W4JJCpRS4OonpuahwaaR4gn6wW09eDgrpXUI5DhxGizwGPLdwENRONpcXP0xnWetC9IaUADHb9yZwQKZhN9RCoO5ytqrt/NkGfn7Si+mWSfMQRGvfgJocC89peIhbchXalT+JS1XWD+Isvj2I+sqmAcoKgji09MTF0lMW+m83/+YA7Jdhn5CLVs9RxZ5cwz1TqveuUaq4i9P867iKCltrqZxxgXD4emZXhHGvGrw8cNQZOVAhc= root@chaotic-dragon"
    ];
  };
  users.users.dragons-ryzen = {
    extraGroups = [ "chaotic_op" ];
    isNormalUser = true;
    openssh.authorizedKeys.keys = [
      "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIAd8nLLjysVefmk3I6BI/IkooUvnGSy7966T54gWNvgW nico@slim-lair"
    ];
  };

  # Ufscar-HPC needs diffie-hellman-group-exchange-sha1
  services.openssh.settings = {
    KexAlgorithms = [
      "curve25519-sha256"
      "curve25519-sha256@libssh.org"
      "diffie-hellman-group-exchange-sha1"
      "diffie-hellman-group16-sha512"
      "diffie-hellman-group18-sha512"
      "sntrup761x25519-sha512@openssh.com"
    ];
  };

  # Our main webserver on this machine
  services.nginx = {
    enable = true;
    virtualHosts = {
      "builds.garudalinux.org" = {
        extraConfig = ''
          # Disable index.html
          index fully_disabled.html;
          # Our beautiful autoindex theme
          autoindex on;
          autoindex_exact_size off;
          autoindex_format xml;
          xslt_string_param path $uri;
          xslt_string_param hostname "Chaotic-AUR main node - Temeraire";

          # Security
          add_header X-XSS-Protection          "1; mode=block" always;
          add_header X-Content-Type-Options    "nosniff" always;
          add_header Referrer-Policy           "no-referrer-when-downgrade" always;
          add_header Content-Security-Policy   "default-src 'self' http: https: data: blob: 'unsafe-inline'; frame-ancestors 'self';" always;
          add_header Permissions-Policy        "interest-cohort=()" always;

          # Locations
          location ~* ^.+\.log {
              default_type text/plain;
          }
          location ~* /repos/(chaotic-aur|garuda)/x86_64/(?!.*(chaotic-aur|garuda)\.(db|files)).+\.tar.* {
              return 301 https://cf-builds.garudalinux.org$request_uri;
              expires 2d;
          }
          location / {
              xslt_string_param path $uri;
              xslt_string_param hostname "Chaotic-AUR main node - Temeraire 🐉";
              xslt_stylesheet "${garuda-lib.xslt_style}";
              location /iso {
                  expires 2d;
                  return 301 https://iso.builds.garudalinux.org$request_uri;
              }
          }
        '';
        http3 = true;
        root = "/srv/http/";
      };
      "cf-builds.garudalinux.org" = {
        extraConfig = ''
          location ~* /repos/(chaotic-aur|garuda)/x86_64/(?!.*(chaotic-aur|garuda)\.(db|files)).+\.tar.* {
              add_header Cache-Control "max-age=150, stale-while-revalidate=150, stale-if-error=86400";
          }
          location ~* /repos/(chaotic-aur|garuda)/x86_64/(chaotic-aur|garuda)\.db.* {
              add_header Cache-Control 'no-cache';
          }
          location /repos/chaotic-aur {
              expires 5m;
              error_page 403 =301 https://builds.garudalinux.org$request_uri;
              error_page 404 =301 https://builds.garudalinux.org$request_uri;
          }
          location /repos/garuda {
              expires 5m;
              error_page 403 =301 https://builds.garudalinux.org$request_uri;
              error_page 404 =301 https://builds.garudalinux.org$request_uri;
          }
          location / {
              expires 2d;
              return 301 https://builds.garudalinux.org$request_uri;
          }
        '';
        http3 = true;
        root = "/srv/http/";
      };
      "iso.builds.garudalinux.org" = {
        extraConfig = ''
          autoindex on;
          autoindex_format xml;
          xslt_string_param path $uri;
          xslt_string_param hostname "Garuda Linux ISO Builds";
        '';
        locations."/".return = "307 https://builds.garudalinux.org";
        locations."/iso" = {
          root = "/var/garuda/buildiso";
          extraConfig = ''
            xslt_stylesheet "${garuda-lib.xslt_style}";
            if ($symlink_target_rel != "") {
              rewrite ^ https://$server_name/iso/$symlink_target_rel redirect;
            }
            if ($arg_sourceforge) {
              rewrite ^/iso/(.*)$ https://sourceforge.net/projects/garuda-linux/files/$1? permanent;
            }
            if ($arg_r2) {
              set $args "";
              rewrite ^/iso/(.*)$ https://r2.garudalinux.org/iso/$1?r2request permanent;
            }
            break;
          '';
        };
      };
    };
  };

  # Explicitly open our firewall ports - HTTPS &amp; rsyncd
  networking.firewall.allowedTCPPorts = [ config.services.rsyncd.port 8384 ];

  # Our rsyncd server
  services.rsyncd = {
    enable = true;
    settings = {
      chaotic = {
        "read only" = "yes";
        comment = "Chaotic-AUR repository";
        exclude = "/chaotic-aur/archive/*** /chaotic-aur/logs/***";
        path = "/srv/http/repos/";
      };
      chaotic-minimal = {
        "read only" = "yes";
        comment = "Chaotic-AUR repository minus largest packages";
        exclude = "/chaotic-aur/archive/*** /chaotic-aur/logs/*** /chaotic-aur/x86_64/quartus* /chaotic-aur/x86_64/unrealtournament4* /chaotic-aur/x86_64/urbanterror*";
        path = "/srv/http/repos/";
      };
      iso = {
        path = "/var/garuda/buildiso/iso/";
        comment = "ISO downloads";
        "read only" = "yes";
      };
      global = {
        "max connections" = 80;
        "max verbosity" = 3;
        "transfer logging" = true;
        "use chroot" = false;
        gid = "nobody";
        uid = "nobody";
      };
    };
  };

  # Push chaotic to r2 hourly automatically
  services.garuda-rclone.chaotic = {
    src = "/srv/http/repos/";
    dest = "r2:/mirror/repos";
    config = garuda-lib.secrets.cloudflare.r2.rclone;
    args = "--s3-upload-cutoff 5G --s3-chunk-size 4G --fast-list --s3-no-head --s3-no-check-bucket --ignore-checksum --s3-disable-checksum -u --use-server-modtime --delete-during --delete-excluded --include /*/x86_64/*.pkg.tar.zst --include /*/lastupdate --order-by modtime,ascending --stats-log-level NOTICE";
    startAt = "hourly";
  };
  systemd.services.chaotic-rclone-inotify = {
    wantedBy = [ "multi-user.target" ];
    after = [ "network-online.target" ];
    wants = [ "network-online.target" ];
    # Get all file changes, upload pkg.tar.zst. Not more than 5 per 5 seconds queued and only one uploaded at the same time. Queue dropped if uploading takes longer than 15 seconds.
    # This prevents the queue from getting overloaded with nonsense requests if that ever were to happen. The hourly sync should take care of this.
    script = ''
      upload() {
        operation="''${1%%|*}"
        path="''${1#*|}"
        relative="$(realpath --relative-to="." "$path")"
        relative="''${relative#./}"
        destpath="r2:/mirror/$relative"
        if [ "$operation" != "MOVED_FROM" ]; then
        ${pkgs.flock}/bin/flock -w 30 /tmp/chaotic-rclone-inotify.lock \
          ${pkgs.rclone}/bin/rclone copyto "$path" "$destpath" --s3-upload-cutoff 5G --s3-chunk-size 4G --s3-no-head --no-check-dest --s3-no-check-bucket --ignore-checksum --s3-disable-checksum --config "${garuda-lib.secrets.cloudflare.r2.rclone}" --stats-one-line -v
        else
          ${pkgs.flock}/bin/flock -w 30 /tmp/chaotic-rclone-inotify.lock ${pkgs.rclone}/bin/rclone deletefile "$destpath" --s3-no-head --no-check-dest --s3-no-check-bucket --config "${garuda-lib.secrets.cloudflare.r2.rclone}" --stats-one-line -v
          (
            ${pkgs.flock}/bin/flock -w 200 -s 200
            ${pkgs.curl}/bin/curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_GARUDALINUX_ORG/purge_cache" -H "Authorization: Bearer $CF_CACHE_API_TOKEN" -H "Content-Type:application/json" --data "{\"files\":[\"https://r2.garudalinux.org/''${relative}\"]}"
            sleep 0.5
          ) 200&gt;/tmp/chaotic-rclone-inotify-invalidate.lock
        fi
      }
      export -f upload
      ${pkgs.inotify-tools}/bin/inotifywait -m ./repos/*/x86_64 -e CLOSE_WRITE,MOVED_TO,MOVED_FROM --format "%e|%w%f" | \
        ${pkgs.gawk}/bin/awk '/\.pkg\.tar\.zst$/ { print $0; fflush(); }' | \
        xargs -rP 0 -I % ${pkgs.bash}/bin/bash -c 'upload "%"'
    '';
    serviceConfig = {
      EnvironmentFile = garuda-lib.secrets.cloudflare.apikeys;
      Restart = "always";
      WorkingDirectory = "/srv/http";
    };
  };

  system.stateVersion = "23.05";
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="web-front"><a class="header" href="#web-front">web-front</a></h1>
<h2 id="general-10"><a class="header" href="#general-10">General</a></h2>
<p>This container is used as a reverse proxy for all of our public facing services.</p>
<h2 id="nix-expression-10"><a class="header" href="#nix-expression-10">Nix expression</a></h2>
<pre><code class="language-nix">{ garuda-lib
, sources
, lib
, ...
}:
let
  allowOnlyCloudflared = config: (
    config // {
      listen = [
        {
          addr = "127.0.0.1";
          port = 80;
        }
      ];
      extraConfig = (config.extraConfig or "") + ''
        real_ip_header CF-Connecting-IP;
        set_real_ip_from 127.0.0.1;
      '';
    }
  );
  # This is technically unecessary, but safety!
  # This refers to the Cloudflare service "Cloudflare Access" to allow only specified users to access the service
  allowOnlyCloudflareZerotrust = base_config:
    let
      config = allowOnlyCloudflared base_config;
    in
    config // {
      extraConfig = config.extraConfig + ''
        ssl_verify_client on;
        underscores_in_headers off;
        ssl_client_certificate ${sources.cloudflare-authenticated_origin_pull_ca};
      '';
      locations = lib.mapAttrs
        (_: location: location // {
          extraConfig = ''
            if ($http_cf_access_authenticated_user_email = "") {
                return 403;
            }
          '' + (location.extraConfig or "");
        })
        config.locations;
    };
  generateCloudflaredIngress = virtualHosts:
    let
      destination = "http://127.0.0.1:80";
      toIngress = array: map (host: { name = host; value = destination; }) array;
      isCloudflared = values: values ? listen &amp;&amp; values.listen == (allowOnlyCloudflared { }).listen;
    in
    builtins.listToAttrs (lib.flatten (lib.mapAttrsToList (host: values: lib.optionals (isCloudflared values) (toIngress ([ host ] ++ (values.serverAliases or [ ])))) virtualHosts));
in
rec {
  imports = sources.defaultModules ++ [ ../modules ];

  # Reverse proxy for our docker-compose stack
  services.nginx = {
    enable = true;
    upstreams = {
      "grafana" = {
        servers = {
          "10.0.5.140:3001" = { };
        };
      };
      "prometheus" = {
        servers = {
          "10.0.5.140:9090" = { };
        };
      };
    };
    virtualHosts = {
      "cloud.garudalinux.org" = {
        addSSL = true;
        extraConfig = ''
          ${garuda-lib.setRealIpFromConfig}
          ${garuda-lib.nginxReverseProxySettings}
        '';
        http3 = true;
        locations = {
          "/" = {
            extraConfig = ''
              # Increase our buffer size to allow bigger up- &amp; downloads
              client_max_body_size                  2048M;
              proxy_max_temp_file_size              2048M;
              proxy_request_buffering               off;

              # HSTS headers
              add_header Strict-Transport-Security "max-age=31536000; includeSubdomains; preload" always;

              # Allow accessing through trusted domain
              set_real_ip_from      172.0.0.0/16;
            '';
            proxyPass = "https://10.0.5.100:443";
          };
          "/.well-known/carddav" = {
            extraConfig = "expires 12h;";
            return = "301 $scheme://$host/remote.php/dav";
          };
          "/.well-known/caldav" = {
            extraConfig = "expires 12h;";
            return = "301 $scheme://$host/remote.php/dav";
          };
          "/.well-known/webfinger" = {
            return = "301 $scheme://$host/index.php/.well-known/webfinger";
            extraConfig = ''
              access_log    off;
              log_not_found off;
            '';
          };
          "/.well-known/nodeinfo" = {
            extraConfig = ''
              access_log    off;
              log_not_found off;
            '';
            return = "301 $scheme://$host/index.php/.well-known/nodeinfo";
          };
        };
        quic = true;
        useACMEHost = "garudalinux.org";
      };
      "cloud-aio.garudalinux.org" = {
        addSSL = true;
        extraConfig = ''
          ${garuda-lib.setRealIpFromConfig}
          ${garuda-lib.nginxReverseProxySettings}
        '';
        http3 = true;
        locations = {
          "/" = {
            extraConfig = ''
              client_body_buffer_size 512k;
              proxy_read_timeout 86400s;
              client_max_body_size 0;

              # Allow accessing through trusted domain
              set_real_ip_from      172.0.0.0/16;
            '';
            proxyPass = "http://10.0.5.100:11000";
          };
        };
        quic = true;
        useACMEHost = "garudalinux.org";
      };
      "cloud-temp.garudalinux.org" = {
        addSSL = true;
        extraConfig = ''
          ${garuda-lib.setRealIpFromConfig}
          ${garuda-lib.nginxReverseProxySettings}
        '';
        http3 = true;
        locations = {
          "/" = {
            extraConfig = ''
              client_body_buffer_size 512k;
              proxy_read_timeout 86400s;
              client_max_body_size 0;

                 # Allow accessing through trusted domain
                 set_real_ip_from      172.0.0.0/16;
            '';
            proxyPass = "https://10.0.5.100:8080";
          };
        };
        quic = true;
        useACMEHost = "garudalinux.org";
      };
      "search.garudalinux.org" = allowOnlyCloudflared {
        addSSL = true;
        http3 = true;
        locations = { "/" = { proxyPass = "http://10.0.5.110:5000"; }; };
        quic = true;
        useACMEHost = "garudalinux.org";
        extraConfig = ''
          ${garuda-lib.nginxReverseProxySettings}
        '';
      };
      "searx.garudalinux.org" = allowOnlyCloudflared {
        addSSL = true;
        http3 = true;
        locations = { "/" = { proxyPass = "http://10.0.5.110:8080"; }; };
        quic = true;
        useACMEHost = "garudalinux.org";
        extraConfig = ''
          ${garuda-lib.nginxReverseProxySettings}
        '';
      };
      "librey.garudalinux.org" = {
        addSSL = true;
        extraConfig = ''
          ${garuda-lib.setRealIpFromConfig}
          ${garuda-lib.nginxReverseProxySettings}
        '';
        http3 = true;
        locations = { "/" = { proxyPass = "http://10.0.5.110:8081"; }; };
        quic = true;
        useACMEHost = "garudalinux.org";
      };
      "ffsync.garudalinux.org" = {
        addSSL = true;
        extraConfig = ''
          ${garuda-lib.setRealIpFromConfig}
          ${garuda-lib.nginxReverseProxySettings}
        '';
        http3 = true;
        locations = { "/" = { proxyPass = "http://10.0.5.100:5001"; }; };
        quic = true;
        useACMEHost = "garudalinux.org";
      };
      "start.garudalinux.org" = {
        addSSL = true;
        extraConfig = ''
          ${garuda-lib.setRealIpFromConfig}
          ${garuda-lib.nginxReverseProxySettings}
        '';
        http3 = true;
        locations = { "/" = { proxyPass = "http://10.0.5.100:8083"; }; };
        quic = true;
        useACMEHost = "garudalinux.org";
      };
      "irc.garudalinux.org" = {
        addSSL = true;
        extraConfig = ''
          ${garuda-lib.setRealIpFromConfig}
          ${garuda-lib.nginxReverseProxySettings}
        '';
        http3 = true;
        locations = { "/" = { proxyPass = "http://10.0.5.100:9000"; }; };
        quic = true;
        useACMEHost = "garudalinux.org";
      };
      "bin.garudalinux.org" = {
        addSSL = true;
        extraConfig = ''
          ${garuda-lib.setRealIpFromConfig}
          ${garuda-lib.nginxReverseProxySettings}
        '';
        http3 = true;
        locations = { "/" = { proxyPass = "http://10.0.5.100:8082"; }; };
        quic = true;
        useACMEHost = "garudalinux.org";
      };
      "bitwarden.garudalinux.org" = {
        addSSL = true;
        extraConfig = ''
          ${garuda-lib.setRealIpFromConfig}
          ${garuda-lib.nginxReverseProxySettings}
        '';
        http3 = true;
        locations = {
          "/" = {
            proxyPass = "http://10.0.5.100:8081";
          };
        };
        quic = true;
        serverAliases = [ "vault.garudalinux.org" ];
        useACMEHost = "garudalinux.org";
      };
      "status.garudalinux.org" = {
        addSSL = true;
        extraConfig = ''
          ${garuda-lib.setRealIpFromConfig}
          ${garuda-lib.nginxReverseProxySettings}
        '';
        http3 = true;
        locations = {
          "/" = { tryFiles = "/status.html /status.html"; };
          "=/status.html" = {
            extraConfig = "expires 30d;";
            root = "${sources.garuda-website}/internal";
          };
        };
        quic = true;
        useACMEHost = "garudalinux.org";
      };
      "stats.garudalinux.org" = {
        addSSL = true;
        extraConfig = ''
          ${garuda-lib.setRealIpFromConfig}
          ${garuda-lib.nginxReverseProxySettings}
        '';
        http3 = true;
        locations = {
          "/" = { tryFiles = "/stats.html /stats.html"; };
          "=/stats.html" = {
            extraConfig = "expires 30d;";
            root = "${sources.garuda-website}/internal";
          };
        };
        quic = true;
        useACMEHost = "garudalinux.org";
      };
      "forum.garudalinux.org" = {
        addSSL = true;
        extraConfig = ''
          client_max_body_size 100M;
          ${garuda-lib.setRealIpFromConfig}
          ${garuda-lib.nginxReverseProxySettings}
        '';
        http3 = true;
        locations = {
          "/" = { proxyPass = "http://10.0.5.70:80"; };
          "/c/announcements/announcements-maintenance/45.json" = {
            extraConfig = "expires 2m;";
            proxyPass = "http://10.0.5.70:80";
          };
        };
        quic = true;
        useACMEHost = "garudalinux.org";
      };
      "social.garudalinux.org" = {
        addSSL = true;
        extraConfig = ''
          client_max_body_size 100M;
          ${garuda-lib.setRealIpFromConfig}
          ${garuda-lib.nginxReverseProxySettings}
        '';
        http3 = true;
        locations = {
          "/" = {
            proxyPass = "https://10.0.5.80:443";
          };
          "/.well-known/webfinger" = {
            proxyPass = "https://10.0.5.80:443";
            extraConfig = ''
              if ($args ~* "resource=acct:(.*)@(chaotic.cx|social.garudalinux.org)$") {
                set $w1 $1;
                rewrite .* /.well-known/webfinger?resource=acct:$w1@garudalinux.org? break;
              }
            '';
          };
        };
        quic = true;
        useACMEHost = "garudalinux.org";
      };
      "social-video.garudalinux.org" = {
        addSSL = true;
        extraConfig = ''
          client_max_body_size 100M;
          ${garuda-lib.setRealIpFromConfig}
          ${garuda-lib.nginxReverseProxySettings}
          location ~* .(mp4|webm)$ {
            proxy_pass https://10.0.5.80:443;
          }
        '';
        locations = {
          "/" = { return = "301 https://social.garudalinux.org$request_uri"; };
        };
        http3 = true;
        quic = true;
        useACMEHost = "garudalinux.org";
      };
      "builds.garudalinux.org" = {
        addSSL = true;
        extraConfig = ''
          proxy_buffering off;
          ${garuda-lib.setRealIpFromConfig}
          ${garuda-lib.nginxReverseProxySettings}
        '';
        http3 = true;
        locations = {
          "/" = {
            proxyPass = "http://10.0.5.20:80";
          };
          # Api of the Chaotic Manager
          "/api/" = {
            proxyPass = "http://10.0.5.140:8080/api/";
          };
          # Api for the website, for displaying news and deploy logs
          "/backend/" = {
            proxyPass = "http://10.0.5.140:3000/";
          };
          "/logs/" = {
            proxyPass = "http://10.0.5.140:8080/";
            extraConfig = ''
              proxy_buffering off;
              proxy_read_timeout 330s;
            '';
          };
        };
        quic = true;
        serverAliases = [ "cf-builds.garudalinux.org" "iso.builds.garudalinux.org" ];
        useACMEHost = "garudalinux.org";
      };
      "element.garudalinux.org" = {
        addSSL = true;
        extraConfig = ''
          ${garuda-lib.setRealIpFromConfig}
          ${garuda-lib.nginxReverseProxySettings}
        '';
        http3 = true;
        locations = {
          "/" = { proxyPass = "http://10.0.5.100:8084"; };
        };
        quic = true;
        useACMEHost = "garudalinux.org";
      };
      "grafana.garudalinux.net" = allowOnlyCloudflareZerotrust {
        locations = {
          "/" = {
            proxyPass = "http://grafana";
            # Workaround the tedious origin not allowed error. This can likely be fixed
            # better, but this works for now. It is behind CF Zero Trust anyways.
            extraConfig = ''
              proxy_set_header Host grafana.garudalinux.net;
              proxy_set_header Origin https://grafana.garudalinux.net;
            '';
          };
          "/api/live/" = {
            proxyPass = "http://grafana";
            proxyWebsockets = true;
            extraConfig = ''
              proxy_set_header Host grafana.garudalinux.net;
              proxy_set_header Origin https://grafana.garudalinux.net;
            '';
          };
        };
      };
      "prometheus.garudalinux.net" = allowOnlyCloudflareZerotrust {
        locations = {
          "/" = {
            proxyPass = "http://prometheus";
          };
        };
      };
      "wiki.garudalinux.org" = {
        addSSL = true;
        extraConfig = ''
          ${garuda-lib.setRealIpFromConfig}
          ${garuda-lib.nginxReverseProxySettings}
        '';
        http3 = true;
        locations = { "/" = { proxyPass = "http://10.0.5.100:3001"; }; };
        quic = true;
        useACMEHost = "garudalinux.org";
      };
      "matrix.garudalinux.org" = {
        addSSL = true;
        http3 = true;
        listen = [
          {
            addr = "0.0.0.0";
            port = 443;
            ssl = true;
          }
          {
            addr = "0.0.0.0";
            port = 8448;
            ssl = true;
          }
        ];
        locations = {
          "/" = {
            extraConfig = "client_max_body_size 50M;";
            proxyPass = "http://10.0.5.100:8008";
          };
        };
        quic = true;
        useACMEHost = "garudalinux.org";
      };
      "lemmy.garudalinux.org" = {
        addSSL = true;
        extraConfig = ''
          ${garuda-lib.setRealIpFromConfig}
          ${garuda-lib.nginxReverseProxySettings}
        '';
        http3 = true;
        locations = {
          "/" = {
            proxyPass = "http://10.0.5.120:80";
          };
        };
        quic = true;
        useACMEHost = "garudalinux.org";
      };
      "lingva.garudalinux.org" = allowOnlyCloudflared {
        addSSL = true;
        http3 = true;
        locations = {
          "/" = {
            proxyPass = "http://10.0.5.110:3002";
          };
        };
        quic = true;
        useACMEHost = "garudalinux.org";
        extraConfig = ''
          ${garuda-lib.nginxReverseProxySettings}
        '';
      };
      "reddit.garudalinux.org" = allowOnlyCloudflared {
        addSSL = true;
        http3 = true;
        locations = {
          "/" = {
            proxyPass = "http://10.0.5.110:8082";
          };
        };
        quic = true;
        useACMEHost = "garudalinux.org";
        extraConfig = ''
          ${garuda-lib.nginxReverseProxySettings}
        '';
      };
      "pgadmin.garudalinux.net" = allowOnlyCloudflareZerotrust {
        locations = {
          "/" = {
            extraConfig = ''
              ${garuda-lib.nginxReverseProxySettings}

              proxy_pass http://10.0.5.50:5050;
              proxy_set_header X-Forwarded-User $http_cf_access_authenticated_user_email;

              proxy_hide_header Cache-Control;
              proxy_hide_header Expires;
              add_header Cache-Control 'no-store';
            '';
          };
        };
      };
      "syncthing-build.garudalinux.net" = allowOnlyCloudflareZerotrust {
        extraConfig = ''
          ${garuda-lib.nginxReverseProxySettings}
        '';
        locations = {
          "/" = {
            extraConfig = ''
              proxy_pass http://10.0.5.20:8384;
              proxy_set_header Authorization "Basic ${garuda-lib.secrets.syncthing.esxi-build.credentials.base64}";
            '';
          };
        };
      };
      "matrixadmin.garudalinux.net" = allowOnlyCloudflareZerotrust {
        extraConfig = ''
          ${garuda-lib.nginxReverseProxySettings}
        '';
        locations = {
          "/" = {
            proxyPass = "http://10.0.5.100:8085";
          };
        };
      };
    };
  };

  services.garuda-cloudflared = {
    enable = true;
    ingress = {
      # "example.garudalinux.net" = "http://10.0.5.100:8085";
    } // (generateCloudflaredIngress services.nginx.virtualHosts);
    tunnel-credentials =
      garuda-lib.secrets.cloudflare.cloudflared.esxi-web.cred;
  };

  system.stateVersion = "23.05";
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="garuda-build-legacy-fosshost-vps"><a class="header" href="#garuda-build-legacy-fosshost-vps">garuda-build (Legacy Fosshost VPS)</a></h2>
<h3 id="general-11"><a class="header" href="#general-11">General</a></h3>
<p>This server is a legacy, still up Fosshost VPS. Fosshost itself ceased to be quite a while ago,
but this server is still up for some reason.
Since we can't be sure how long it will stay up, we don't want to put anything important on it.
Therefore, its sole purpose is running a disposable build environment for the Chaotic-AUR infra 4.0</p>
<h3 id="nix-expression-11"><a class="header" href="#nix-expression-11">Nix expression</a></h3>
<pre><code class="language-nix">{ pkgs
, sources
, ...
}:
let
  wrapperScript = pkgs.writeScriptBin "chaotic-restart" ''
    systemctl restart docker-compose-chaotic-v4-builder-root.target 
  '';
in
{
  imports = [
    "${sources.chaotic-portable-builder}/nix/nixos.nix"
    ../modules
    ./garuda-build/docker-compose.nix
    ./garuda-build/hardware-configuration.nix
  ];

  # Base configuration
  networking.interfaces.ens18.ipv4.addresses = [{
    address = "216.158.66.108";
    prefixLength = 24;
  }];
  networking.hostName = "garuda-build";
  networking.defaultGateway = "216.158.66.97";

  # At least try to prevent the insane spam of login attempts
  services.openssh.ports = [ 1022 ];

  # Lock down chaotic-op group to SCP in landing zone
  services.openssh.extraConfig = ''
    Match Group chaotic-op
      AllowAgentForwarding no
      AllowTCPForwarding yes
      ForceCommand internal-sftp
      PermitOpen 127.0.0.1:6379
      PermitTunnel no
      X11Forwarding no
  '';

  # Enable the user accounts of chaotic maintainers
  garuda-lib.chaoticUsers = true;

  # Allow controlling infra 4.0's containers without root
  environment.systemPackages = [ wrapperScript ];
  security.sudo.extraRules = [
    { users = [ "xiota" ]; commands = [{ command = "${wrapperScript}/bin/chaotic-restart"; options = [ "NOPASSWD" ]; }]; }
  ];

  system.stateVersion = "22.05";
}
</code></pre>
<h3 id="docker-containers-3"><a class="header" href="#docker-containers-3">Docker containers</a></h3>
<pre><code class="language-nix"># Auto-generated using compose2nix v0.2.2-pre.
{ pkgs, lib, ... }:

{
  # Runtime
  virtualisation.docker = {
    enable = true;
    autoPrune.enable = true;
  };
  virtualisation.oci-containers.backend = "docker";

  # Containers
  virtualisation.oci-containers.containers."chaotic-builder" = {
    image = "registry.gitlab.com/garuda-linux/tools/chaotic-manager/manager:latest";
    environment = {
      "BUILDER_HOSTNAME" = "garuda-build";
      "BUILDER_TIMEOUT" = "8600";
      "CI_CODE_SKIP" = "123";
      "DATABASE_HOST" = "builds.garudalinux.org";
      "DATABASE_PORT" = "400";
      "REDIS_SSH_HOST" = "builds.garudalinux.org";
      "REDIS_SSH_PORT" = "400";
      "REDIS_SSH_USER" = "package-deployer";
      "SHARED_PATH" = "/var/garuda/docker-compose-runner/chaotic-v4/shared";
    };
    volumes = [
      "/var/garuda/docker-compose-runner/chaotic-v4/shared:/shared:rw"
      "/var/garuda/docker-compose-runner/chaotic-v4/sshkey:/app/sshkey:rw"
      "/var/run/docker.sock:/var/run/docker.sock:rw"
    ];
    cmd = [ "builder" ];
    log-driver = "journald";
    extraOptions = [
      "--network-alias=chaotic-builder"
      "--network=chaotic-v4-builder_default"
    ];
    environmentFiles = [
      "/var/garuda/secrets/docker-compose/chaotic-v4-builder.env"
    ];
  };
  systemd.services."docker-chaotic-builder" = {
    serviceConfig = {
      Restart = lib.mkOverride 500 "no";
    };
    after = [
      "docker-network-chaotic-v4-builder_default.service"
    ];
    requires = [
      "docker-network-chaotic-v4-builder_default.service"
    ];
    partOf = [
      "docker-compose-chaotic-v4-builder-root.target"
    ];
    wantedBy = [
      "docker-compose-chaotic-v4-builder-root.target"
    ];
    unitConfig.RequiresMountsFor = [
      "/var/garuda/docker-compose-runner/chaotic-v4/shared"
      "/var/garuda/docker-compose-runner/chaotic-v4/sshkey"
      "/var/run/docker.sock"
    ];
  };
  virtualisation.oci-containers.containers."watchtower" = {
    image = "containrrr/watchtower:latest";
    volumes = [
      "/var/run/docker.sock:/var/run/docker.sock:rw"
    ];
    cmd = [ "--cleanup" "chaotic-builder" "watchtower" "--interval" "3600" ];
    log-driver = "journald";
    extraOptions = [
      "--network-alias=watchtower"
      "--network=chaotic-v4-builder_default"
    ];
  };
  systemd.services."docker-watchtower" = {
    serviceConfig = {
      Restart = lib.mkOverride 500 "always";
      RestartMaxDelaySec = lib.mkOverride 500 "1m";
      RestartSec = lib.mkOverride 500 "100ms";
      RestartSteps = lib.mkOverride 500 9;
    };
    after = [
      "docker-network-chaotic-v4-builder_default.service"
    ];
    requires = [
      "docker-network-chaotic-v4-builder_default.service"
    ];
    partOf = [
      "docker-compose-chaotic-v4-builder-root.target"
    ];
    wantedBy = [
      "docker-compose-chaotic-v4-builder-root.target"
    ];
    unitConfig.RequiresMountsFor = [
      "/var/run/docker.sock"
    ];
  };

  # Networks
  systemd.services."docker-network-chaotic-v4-builder_default" = {
    path = [ pkgs.docker ];
    serviceConfig = {
      Type = "oneshot";
      RemainAfterExit = true;
      ExecStop = "docker network rm -f chaotic-v4-builder_default";
    };
    script = ''
      docker network inspect chaotic-v4-builder_default || docker network create chaotic-v4-builder_default
    '';
    partOf = [ "docker-compose-chaotic-v4-builder-root.target" ];
    wantedBy = [ "docker-compose-chaotic-v4-builder-root.target" ];
  };

  # Root service
  # When started, this will automatically create all resources and start
  # the containers. When stopped, this will teardown all resources.
  systemd.targets."docker-compose-chaotic-v4-builder-root" = {
    unitConfig = {
      Description = "Root target generated by compose2nix.";
    };
    wantedBy = [ "multi-user.target" ];
  };
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="garuda-mail-netcup-vps"><a class="header" href="#garuda-mail-netcup-vps">garuda-mail (Netcup VPS)</a></h2>
<h3 id="general-12"><a class="header" href="#general-12">General</a></h3>
<p>This system mainly consists of the <a href="https://gitlab.com/simple-nixos-mailserver/nixos-mailserver">simple-nixos-mailserver</a>.
Its only purpose is providing a mail service to team members.
The current config looks like <a href="https://gitlab.com/garuda-linux/infra-nix/-/blob/main/nixos/hosts/garuda-mail.nix?ref_type=heads#L47">this</a>.
In case of issues, the <a href="https://nixos-mailserver.readthedocs.io/en/latest/">documentation</a> can be consulted.</p>
<h3 id="mail-server-setup"><a class="header" href="#mail-server-setup">Mail server setup</a></h3>
<p>The mail server details are as follows:</p>
<ul>
<li>host: <code>mail.garudalinux.net</code></li>
<li>username: full email address</li>
<li>password: given password</li>
<li>incoming: IMAP via <code>993</code> (SSL)</li>
<li>outgoing: SMTP via <code>587/465</code> (STARTTLS/SSL)</li>
</ul>
<p>Additionally, it is possible to make use of the <a href="https://mail.garudalinux.net">Roundcube-powered web interface</a>.</p>
<h3 id="roundcube"><a class="header" href="#roundcube">Roundcube</a></h3>
<p>Roundcube is used to provide a web interface for our mail accounts.
It features a few plugins to enhance the general user experience.</p>
<h4 id="plugins"><a class="header" href="#plugins">Plugins</a></h4>
<ul>
<li>attachment_reminder - reminds about forgotten attachments</li>
<li>authres_status - checks for whether SPF/DKIM/DMARC match the sending domain</li>
<li>carddav - allows adding a CardDAV contact book as source (eg. Nextcloud)</li>
<li>contextmenu - adds a right click context menu to the most pages</li>
<li>custom_from - allows customizing from address</li>
<li>managesieve - allows managing Sieve rules, which automatically sort incoming mails based on rules</li>
<li>newmail_notifier - new mail notifier for desktops</li>
<li>persistent_login - allows storing a persistent login cookie for no more login prompts</li>
<li>thunderbird_labels - shows Thunderbird labels</li>
<li>zipdownload - allows downloading all attachments at once</li>
</ul>
<h3 id="backups-1"><a class="header" href="#backups-1">Backups</a></h3>
<p>Backups are happening daily via Borg. A Hetzner storage box is used to store multiple generations of backups.</p>
<h3 id="creating-a-new-user"><a class="header" href="#creating-a-new-user">Creating a new user</a></h3>
<p>A new user can be created be adding a new <code>loginAccounts</code> value and supplying the password via <code>secrets</code>.
We make use of <code>hashedPasswordFile</code>, therefore, new hashes can be generated by running <code>nix-shell -p mkpasswd --run 'mkpasswd -sm bcrypt'</code>. Add it to the <code>secrets</code>, then execute <code>deploy</code> and <code>apply</code>.
Don't forget to commit both changes.</p>
<h3 id="issues-and-their-solution"><a class="header" href="#issues-and-their-solution">Issues and their solution</a></h3>
<h4 id="local-dns-resolver-failing-to-start"><a class="header" href="#local-dns-resolver-failing-to-start">Local DNS resolver failing to start</a></h4>
<p>Simple NixOS mail server runs a local DNS server to prevent the log filling up with junk (<a href="https://mailserver.readthedocs.io/en/latest/options.html#cmdoption-arg-mailserver.localDnsResolver">source</a>).
There can be cases of the persisted files need to be deleted in order for the service to recover from dumping core.
See <a href="https://gitlab.nic.cz/knot/knot-resolver/-/issues/627">this issue</a> for reference.</p>
<h3 id="nix-expression-12"><a class="header" href="#nix-expression-12">Nix expression</a></h3>
<pre><code class="language-nix">{ config
, lib
, pkgs
, ...
}:
let
  authres_status = pkgs.roundcubePlugins.roundcubePlugin rec {
    pname = "authres_status";
    version = "0.6.3";
    src = pkgs.fetchzip {
      url = "https://github.com/pimlie/authres_status/archive/refs/tags/${version}.zip";
      hash = "sha256-WebJiN0vRkvc0AKvMm+inK3FY37R04q3y/0rFoiUW6A=";
    };
  };
in
{
  imports = [
    ../modules
    ./garuda-mail/hardware-configuration.nix
  ];

  # Base configuration
  networking.interfaces.ens3.ipv4.addresses = [{
    address = "94.16.112.218";
    prefixLength = 22;
  }];
  networking.hostName = "garuda-mail";
  networking.defaultGateway = "94.16.112.3";

  # GRUB
  boot.loader.grub.devices = [ "/dev/vda" ];

  # Backup configurations to Hetzner storage box
  programs.ssh.macs = [ "hmac-sha2-512" ];
  services.borgbackup.jobs = {
    backupToHetzner = {
      compression = "auto,zstd";
      doInit = true;
      encryption = {
        mode = "repokey-blake2";
        passCommand = "cat /var/garuda/secrets/backup/repo_key";
      };
      environment = {
        BORG_RSH = "ssh -i /var/garuda/secrets/backup/ssh_garuda-mail -p 23";
      };
      paths = [ config.mailserver.mailDirectory "/var/dkim" ];
      prune.keep = {
        within = "1d";
        daily = 5;
        weekly = 2;
        monthly = 1;
      };
      repo = "u358867@u358867.your-storagebox.de:./garuda-mail";
      startAt = "daily";
    };
  };

  # NixOS Mailserver
  mailserver = {
    certificateScheme = "acme-nginx";
    dmarcReporting = {
      domain = "garudalinux.org";
      enable = true;
      organizationName = "Garuda Linux";
    };
    domains = [ "garudalinux.org" "chaotic.cx" "dr460nf1r3.org" ];
    enable = true;
    enableManageSieve = true;
    # Forwards (mostly chaotic.cx only)
    forwards =
      {
        "coffee-machine@chaotic.cx" = "root@pedrohlc.com";
        "islandc0der@chaotic.cx" = "jf.mundox@gmail.com";
        "pedrohlc@chaotic.cx" = "root@pedrohlc.com";
        "xstefen@chaotic.cx" = "me@xstefen.dev";
      };
    fqdn = "mail.garudalinux.net";
    fullTextSearch = {
      enable = true;
      enforced = "body";
      indexAttachments = true;
      memoryLimit = 512;
    };
    # To create the password hashes, use nix-shell -p mkpasswd --run 'mkpasswd -sm bcrypt'
    loginAccounts = {
      # garudalinux.org
      "cloud@garudalinux.org" = {
        hashedPasswordFile = "/var/garuda/secrets/mail/cloudatgl";
        sendOnly = true;
      };
      "complaints@garudalinux.org" = {
        hashedPasswordFile = "/var/garuda/secrets/mail/complaintsatgl";
      };
      "dr460nf1r3@garudalinux.org" = {
        hashedPasswordFile = "/var/garuda/secrets/mail/dr460nf1r3atgl";
      };
      "filo@garudalinux.org" = {
        hashedPasswordFile = "/var/garuda/secrets/mail/filoatgl";
      };
      "gitlab@garudalinux.org" = {
        hashedPasswordFile = "/var/garuda/secrets/mail/gitlabatgl";
      };
      "mastodon@garudalinux.org" = {
        hashedPasswordFile = "/var/garuda/secrets/mail/mastodonatgl";
        sendOnly = true;
      };
      "naman@garudalinux.org" = {
        hashedPasswordFile = "/var/garuda/secrets/mail/namanatgl";
      };
      "noreply@garudalinux.org" = {
        hashedPasswordFile = "/var/garuda/secrets/mail/noreplyatgl";
      };
      "rohit@garudalinux.org" = {
        hashedPasswordFile = "/var/garuda/secrets/mail/rohitatgl";
      };
      "security@garudalinux.org" = {
        hashedPasswordFile = "/var/garuda/secrets/mail/securityatgl";
      };
      "sgs@garudalinux.org" = {
        hashedPasswordFile = "/var/garuda/secrets/mail/sgsatgl";
      };
      "spam-reports@garudalinux.org" = {
        hashedPasswordFile = "/var/garuda/secrets/mail/spam-reportsatgl";
      };
      "team@garudalinux.org" = {
        aliases = [
          "admin@garudalinux.org"
          "ci@garudalinux.org"
          "root@garudalinux.org"
          "webmaster@garudalinux.org"
        ];
        hashedPasswordFile = "/var/garuda/secrets/mail/teamatgl";
      };
      "tne@garudalinux.org" = {
        hashedPasswordFile = "/var/garuda/secrets/mail/tneatgl";
      };
      "yorper@garudalinux.org" = {
        hashedPasswordFile = "/var/garuda/secrets/mail/yorperatgl";
      };
      # chaotic.cx
      "actions@chaotic.cx" = {
        aliases = [ "temeraire@chaotic.cx" ];
        hashedPasswordFile = "/var/garuda/secrets/mail/actionsatcx";
      };
      "nico@chaotic.cx" = {
        aliases = [
          "dr460nf1r3@chaotic.cx"
          "root@chaotic.cx"
          "webmaster@chaotic.cx"
        ];
        hashedPasswordFile = "/var/garuda/secrets/mail/nicoatcx";
      };
      # dr460nf1r3.org
      "nico@dr460nf1r3.org" = {
        aliases = [ "@dr460nf1r3.org" ];
        catchAll = [ "dr460nf1r3.org" ];
        hashedPasswordFile = "/var/garuda/secrets/mail/nicoatdf";
      };
      "test@dr460nf1r3.org" = {
        hashedPasswordFile = "/var/garuda/secrets/mail/testatdf";
      };
    };
    indexDir = "/var/lib/dovecot/indices";
    monitoring = {
      alertAddress = "team@garudalinux.org";
      enable = true;
    };
    rebootAfterKernelUpgrade.enable = true;
  };

  # Fix dovecot errors caused by failed scudo allocations
  environment.memoryAllocator.provider = lib.mkForce "libc";

  # Postmaster alias
  services.postfix.postmasterAlias = "nico@dr460nf1r3.org";

  # Web UI
  services.roundcube = {
    enable = true;
    # this is the url of the vhost, not necessarily the same as the fqdn of
    # the mailserver
    hostName = "mail.garudalinux.net";
    extraConfig = ''
      # starttls needed for authentication, so the fqdn required to match
      # the certificate
      $config['smtp_server'] = "tls://${config.mailserver.fqdn}";
      $config['smtp_user'] = "%u";
      $config['smtp_pass'] = "%p";
    '';
    package = pkgs.roundcube.withPlugins (
      plugins: [
        authres_status
        plugins.carddav
        plugins.contextmenu
        plugins.custom_from
        plugins.persistent_login
        plugins.thunderbird_labels
      ]
    );
    plugins = [
      "attachment_reminder" # Roundcube internal plugin
      "authres_status"
      "carddav"
      "contextmenu"
      "custom_from"
      "managesieve" # Roundcube internal plugin
      "newmail_notifier" # Roundcube internal plugin
      "persistent_login"
      "thunderbird_labels"
      "zipdownload" # Roundcube internal plugin
    ];
  };

  # At least try to prevent the insane spam of login attempts
  services.openssh.ports = [ 1022 ];

  # This mostly sends annoying notifications because SSH port is non-default
  services.monit.enable = lib.mkForce false;

  system.stateVersion = "22.05";
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="repositories"><a class="header" href="#repositories">Repositories</a></h1>
<h2 id="notifications-for-new-events-at-gitlab"><a class="header" href="#notifications-for-new-events-at-gitlab">Notifications for new events at GitLab</a></h2>
<p>Since GitLab has an inbuilt Telegram integration, we can leverage this feature to send notifications to our a dedicated <a href="https://t.me/garuda_updates">Telegram development updates channel</a>.
Posts are sent for all kinds of relevant, but non-confidential events like commits, comments or new merge requests. Failed pipelines would also be reported here.</p>
<h2 id="backing-up-current-repositories"><a class="header" href="#backing-up-current-repositories">Backing up current repositories</a></h2>
<p>Current repositories may be backed up using <a href="https://github.com/gabrie30/ghorg">ghorg</a>.
In order to use ghorg, one needs a GitLab access token and the application itself. To generate a fitting token, follow <a href="https://github.com/gabrie30/ghorg?tab=readme-ov-file#gitlab-setup">these instructions</a>.</p>
<pre><code class="language-sh">ghorg clone --scm gitlab --token "glpat-1234567890" garuda-linux # regular system
nix run nixpkgs#ghorg -- clone --scm gitlab --token "glpat-1234567890" garuda-linux # oneliner on Nix
</code></pre>
<h2 id="archive"><a class="header" href="#archive">Archive</a></h2>
<p>We have an <a href="https://gitlab.com/garuda-linux/archive">archive repository</a> for all files, which are no longer needed for our current operations.
It contains old PKGBUILDs and settings packages, eg. the state of the ones before we moved to a unified PKGBUILD repository.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pkgbuilds"><a class="header" href="#pkgbuilds">PKGBUILDs</a></h1>
<h2 id="types-of-pkgbuilds"><a class="header" href="#types-of-pkgbuilds">Types of PKGBUILDs</a></h2>
<p>There are 2 types of repo packaging-wise:</p>
<ol>
<li>The ones that have all required files in the new pkgbuilds repo and don't reference any external repo in PKGBUILDs <code>source()</code></li>
<li>The ones requiring external repositories as a source. These are listed in the SOURCES files below, packages <em>not</em> listed here are automatically packages of the first category:</li>
</ol>
<p><a href="https://gitlab.com/garuda-linux/pkgbuilds/-/blob/main/SOURCES">This file</a> provides the needed information to check for the new version with the scheme <code>$repourl $pkgbuildPathInPkgbuildsRepo $GitlabProjectId</code></p>
<h2 id="releasing-a-new-version"><a class="header" href="#releasing-a-new-version">Releasing a new version</a></h2>
<p>This means executing the following for doing changes and releasing a new version:</p>
<ol>
<li>Would be modified directly in the new pkgbuilds repo, along with their source.
Versions are bumped in the PKGBUILD itself and deployments need to happen by increasing <code>pkgver</code> + supplying a fitting commit message (append <em>[deploy pkgname ]</em> to it)</li>
<li>In case of modifying these, one would make the changes to the source files repo (not the new PKGBUILDs one).
Then, if a new version should be built, one would push the corresponding tag to that repo (omitting "v", adding v breaks the PKGBUILD!).
That's everything needed in case no packaging changes (adding new dependencies for example) that require changing the PKGBUILD occur.
The <a href="https://gitlab.com/garuda-linux/pkgbuilds/-/pipeline_schedules">half-hourly pipeline</a> of the <a href="https://gitlab.com/garuda-linux/pkgbuilds">PKGBUILD repo</a> then checks for the existence of a new tag.
Once a new one gets detected, the PKGBUILD gets updated and deployment occurs via <code>[deploy *]</code> in the commit message.
<em>If PKGBUILD changes need to be implemented, this would of course indicate doing it as described in 1. This would increase pkgrel only and not the actual version.</em></li>
</ol>
<p>There are currently three bash scripts responsible for CI/CD:</p>
<ul>
<li><a href="https://gitlab.com/garuda-linux/pkgbuilds/-/blob/main/.ci/lint.sh?ref_type=heads">Checking PKGBUILDs/code style</a></li>
<li><a href="https://gitlab.com/garuda-linux/pkgbuilds/-/blob/main/.ci/version-bump.sh?ref_type=heads">Updating the package versions automatically</a></li>
<li><a href="https://gitlab.com/garuda-linux/pkgbuilds/-/blob/main/.ci/what-to-deploy.sh?ref_type=heads">Triggering automated deployments via commit message</a></li>
</ul>
<p>Past pipeline runs may be reviewed by visiting the <a href="https://gitlab.com/garuda-linux/pkgbuilds/-/pipelines">pipelines</a> page.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chaotic-aur-infra-40"><a class="header" href="#chaotic-aur-infra-40">Chaotic-AUR infra 4.0</a></h1>
<p>This is a manual for handling our new Chaotic-AUR infrastructure, which is based on GitLab CI and GitHub Actions.
It is powering the <code>garuda</code> repository, which contains all PKGBUILDs and other necessary files to build packages for
Garuda Linux.
Content has mostly been pasted from the original documentation for visibility.</p>
<h2 id="reasoning"><a class="header" href="#reasoning">Reasoning</a></h2>
<p>Our previous build tools, the so-called <a href="https://github.com/chaotic-aur/toolbox">toolbox</a> was initially created by
@pedrohlc to deal with one issue: having a lot of packages to compile while not having many maintainers for all of the
packages.
Additionally, Chaotic-AUR has quite inhomogeneous builders: servers, personal devices, and one HPC which all need to be
integrated somehow.
The toolbox had a nice approach to this - keeping things as KISS as possible and using Git to distribute package builds
between builders. These would then grab builds according to their activated routines. While this works fairly well, it
had a few problems which we tried to get rid of in the new version.
A few key ideas about this new setup:</p>
<ul>
<li>Since we like working with CI a lot besides it providing great enhancement for automating boring tasks as well as
making the whole process more transparent to the public as well, it was clear CI should be a major part of it.</li>
<li>The system should have a scheduler that distributes build tasks to nodes, which prevents useless build routines and
enables nodes to grab jobs whenever they are queued.</li>
<li>The tools should be available as Docker containers to make them easy to use on other systems than Arch.</li>
<li>All logic besides the scheduler (which is written in TypeScript using BullMQ) should be written in Bash</li>
</ul>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How it works</a></h2>
<p>The new system consists of three integral parts:</p>
<ul>
<li>The CI (which can be both GitLab CI and GitHub Actions!) handles PKGBUILDs, their changes, and figuring out what to
build, utilizing a Chaotic Manager container to schedule packages via the central Redis instance.</li>
<li>The central Redis instance storing information about currently scheduled builds.</li>
<li>The <a href="https://gitlab.com/garuda-linux/tools/chaotic-manager">Chaotic Manager</a> which is used to add new builds to the
queue and execute them via the main manager container. All containers have SSH-tunneled access to the Redis instance,
enabling the build containers to grab new builds whenever they enter the queue.</li>
</ul>
<p>Compared to Infra 3.0, this means we have the following key differences:</p>
<ul>
<li>We no longer have package lists but a repository full of PKGBUILD folders. These PKGBUILDs are getting pulled either
from AUR once a package has been updated or updated manually in case a Git repository and its tags serve as a source.</li>
<li>No more dedicated builders (might change in the future, eg. for heavy builds?) but a common build queue.</li>
<li>Routines are no longer necessary - CI determines and adds packages to the schedule as needed. The only "routine-like"
thing we have is the CI schedule, executing tasks like PKGBUILD or version updates.</li>
<li>The actual logic behind the build process (like <code>interfere.sh</code> or database management) was moved to
the <a href="https://gitlab.com/garuda-linux/tools/chaotic-manager/-/tree/main/builder-container?ref_type=heads">builder container of Chaotic Manager</a> -
this one updates daily/on-commit and gets pulled regularly by the Manager instance.</li>
<li>Live-updating build logs will be available via CI - multiple revisions instead of only the latest.</li>
<li>The interfere repo is no longer needed, instead, package builds can be configured via the <code>.CI</code> folder in their
respective PKGBUILD folders. All known interfere types can be put here (eg. <code>PKGBUILD.append</code> or <code>prepare.sh</code>),
keeping existing interferes working.</li>
<li>The CI's behavior concerning each package can be configured via a <code>config</code> file in the <code>.CI</code> folder: this file stores
information like PKGBUILD source (it can be AUR or something different), PKGBUILD timestamp on AUR, most recent Git
commit as well as settings like whether to push a PKGBUILD change back to AUR.</li>
<li>PKGBUILD changes can now be reviewed in case of major (all changes other than pkgver, hashes, pkgrel) updates - CI
automatically creates a PR containing the changes for human review.</li>
<li>Adding and removing packages is entirely controlled via Git - after adding a new PKGBUILD folder via commit, the
corresponding package will automatically be deployed. Removing it has the opposite effect.</li>
</ul>
<h2 id="workflows-and-information"><a class="header" href="#workflows-and-information">Workflows and information</a></h2>
<h3 id="adding-packages"><a class="header" href="#adding-packages">Adding packages</a></h3>
<p>Adding packages is as easy as creating a new folder named after the <code>$pkgbase</code> of the package. Put the PKGBUILD and all
other required files in here.
Adding AUR packages is therefore as simple as cloning its repo and removing the <code>.git</code> folder.
CI relies on <code>.SRCINFO</code> files to parse most information, therefore, it is important to have them in place and up-to-date
in case of self-managed packages.
Finally, add a <code>.CI</code> folder containing the basic config (<code>CI_PKGBUILD_SOURCE</code> is required in case its external package,
self-managed PKBUILDs don't need it), commit any changes, and push the changes back to the main branch.
Please follow the <a href="https://www.conventionalcommits.org/en/v1.0.0/">conventional commit convention</a> while doing
so (<a href="https://github.com/commitizen/cz-cli">cz-cli</a> can help with that!). This means commits like:</p>
<ul>
<li><code>feat($pkgname): init</code></li>
<li><code>fix($pkgname): fix xyz</code></li>
<li><code>chore($pkgname): update PKGBUILD</code></li>
<li><code>ci(config): update</code></li>
</ul>
<p>This not only helps with having a uniform commit history, it also allows automatic changelog generation.</p>
<h3 id="removing-packages"><a class="header" href="#removing-packages">Removing packages</a></h3>
<p>This can be done by removing the folder containing a package's PKGBUILD. A cleanup job will then automatically remove
any obsolete package via the <code>on-commit</code> pipeline run. This will also consider any split packages that a package might
produce.
Renaming folders does also count as removing packages.</p>
<h3 id="on-commit-pipeline"><a class="header" href="#on-commit-pipeline">On-commit pipeline</a></h3>
<p>Whenever pushing a new commit, the CI pipeline will carry out the following actions:</p>
<ul>
<li>Checking when the last <code>scheduled</code> tag was created. This is used to determine which packages need to be scheduled.</li>
<li>It parses each commit for a <code>[deploy $foldername]</code> string, only accepting valid values derived from the existing
PKGBUILD folders. <code>[deploy all]</code> is a valid parameter as well. Misspelling <code>$pkgname</code> is a fatal error here. Any
issues must be fixed and force-pushed.</li>
<li>Then, the changed files are parsed. This also includes removed packages. Any changed relevant folder content will
cause a package deployment of the corresponding package.</li>
<li>The final action is to build the schedule parameters (handing it over to the scheduled job via artifacts) and remove
all obsolete packages in case an earlier step is detected.</li>
<li>In case all of these actions succeed, the <code>scheduled</code> tag gets updated, so we can refer to it on a later pipeline run.</li>
</ul>
<h3 id="on-schedule-pipeline"><a class="header" href="#on-schedule-pipeline">On-schedule pipeline</a></h3>
<h4 id="half-hourly"><a class="header" href="#half-hourly">Half-hourly</a></h4>
<p>Every half an hour, the on-schedule pipeline will carry out a few tasks:</p>
<ul>
<li>Updating the CI template from the template repository (in case this is enabled via <code>.ci/config</code>)</li>
<li>Check if the scheduled tag does not exist or scheduled does not point to HEAD (in this case abort mission!)</li>
<li>Check whether the .state worktree containing the state of the packages exists, if it does, it sets it up. Otherwise,
it re-creates it from scratch (e.g., on force push)</li>
<li>Check whether the last commit is automated (containing "chore(packages): update packages [skip ci]"), if yes, the
commit resulting from the schedule will overwrite it to keep the commit history clean.</li>
<li>Collect AUR timestamps of packages to determine whether a PKGBUILD changed</li>
<li>Loop through each valid package and carry out the following actions:
<ul>
<li>Read the <code>.CI/config</code> file to gain information about the package configuration (e.g., whether to manage the AUR
repository, the source of the PKGBUILD, etc.)</li>
<li>Update PKGBUILD in the following cases:
<ul>
<li>CI_PKGBUILD_SOURCE is set to <code>gitlab</code>: Updates the PKGBUILD from the GitLab repository tags</li>
<li>CI_PKGBUILD_SOURCE is set to <code>aur</code>: Updates the PKGBUILD from the AUR repository, pulling in the git repo and
replacing the existing files with the new ones.
If the AUR timestamp could not be collected earlier, the package update gets skipped.</li>
<li>CI_PKGBUILD_SOURCE is not set to <code>gitlab</code> or <code>aur</code>:
tries to update the PKGBUILD by pulling the repository specified in CI_PKGBUILD_SOURCE.
In case cloning was not successful after 2 tries, the update process gets skipped.</li>
</ul>
</li>
<li>In case CI_GIT_COMMIT is set in the packages configuration variables, the latest commit of the git URL set in
the <code>source</code> section of the PKGBUILD is
updated. If it differs, schedule a build.</li>
<li>In case a custom hook exists (<code>.CI/update.sh</code> inside the package directory), it gets executed - this can be used
for
updating PKGBUILDs with a custom script.</li>
<li>Writing needed variables back to <code>.CI/config</code> (eg. Git hash)</li>
</ul>
</li>
<li>Either update the PKGBUILD silently in case of minor changes, create a PR for review in case of major updates (and
only if <code>CI_HUMAN_REVIEW</code> is true)
<ul>
<li>Updates are only considered if diff actually reports changes between current PKGBUILD folder and AUR PKGBUILD repo</li>
<li>Any change made to the source files is detected, this however does <em>not</em> detect malicious changes in the upstream
project source that the package builds</li>
</ul>
</li>
<li>The state worktree gets updated with new information</li>
<li>Schedule parameters are getting built and handed over to the scheduled job via artifact</li>
<li>Obsolete branches (eg. merged review PRs) are getting pruned</li>
<li>The scheduled tag gets updated again</li>
</ul>
<h4 id="daily"><a class="header" href="#daily">Daily</a></h4>
<p>A daily pipeline schedule has been added for specific packages which generate their <code>pkgver</code> dynamically.
To make use of it, set <code>CI_ON_TRIGGER=daily</code> inside the <code>.CI/config</code> file of the package.</p>
<h3 id="manual-scheduling"><a class="header" href="#manual-scheduling">Manual scheduling</a></h3>
<h4 id="scheduling-packages-without-git-commits"><a class="header" href="#scheduling-packages-without-git-commits">Scheduling packages without git commits</a></h4>
<p>Packages can be added to the schedule manually by going to
the <a href="https://gitlab.com/chaotic-aur/pkgbuilds/-/pipelines">pipeline runs</a> page, selecting "Run pipeline" and
adding <code>PACKAGES</code> as a variable with the package names as its value. The pipeline will then pick up the packages and
schedule them.
<code>PACKAGES</code> can also be set to <code>all</code> to schedule all packages. In case one or many packages are getting scheduled, it
needs to follow the format <code>pkgname1:pkgname2:pkgname3</code>.</p>
<h4 id="running-scheduled-pipelines-on-demand"><a class="header" href="#running-scheduled-pipelines-on-demand">Running scheduled pipelines on-demand</a></h4>
<p>This can be done by going to the <a href="https://gitlab.com/chaotic-aur/pkgbuilds/-/pipeline_schedules">pipeline runs</a> page,
selecting "Run pipeline" (the play symbol). A link to the pipeline page will be provided, where the pipeline logs can be
obtained.</p>
<h3 id="adding-interfere"><a class="header" href="#adding-interfere">Adding interfere</a></h3>
<p>Put the required interfere file in the <code>.CI</code> folder of a PKGBUILD folder:</p>
<ul>
<li>
<p><code>prepare</code>: A script that is executed after the building chroot has been set up. It can be used to source
environment variables or modify other things before compilation starts.</p>
<ul>
<li>If something needs to be set up before the actual compilation process, commands can be pushed by inserting
eg. <code>$CAUR_PUSH 'source /etc/profile'</code>. Likewise, package conflicts can be solved, eg. as
follows: <code>$CAUR_PUSH 'yes | pacman -S nftables'</code> (single quotes are important because we want the variables/pipes
to
evaluate in the guest's runtime and not while interfering)</li>
</ul>
</li>
<li>
<p><code>interfere.patch</code>: a patch file that can be used to fix multiple files when many changes are
required. All changes need to be added to this file.</p>
</li>
<li>
<p><code>PKGBUILD.prepend</code>: contents of this file are added to the beginning of PKGBUILD.
This can be used to set configuration variables.</p>
</li>
<li>
<p><code>PKGBUILD.append</code>: contents of this file are added to the end of PKGBUILD.
This can be used for all kinds of fixes.
To fix <code>build()</code>, include the replacement in this file.
To add an item to an array, <code>makedepend+=(somepackage)</code>.</p>
<p>To skip build, <code>return $CI_CODE_SKIP</code>. This can be used to conditionally skip builds based on upstream check-in
results. See <code>kicad-git</code> for a GitLab example. See <code>openvino-git</code> and <code>scummvm-git</code> for GitHub examples.</p>
</li>
<li>
<p><code>on-failure.sh</code>: A script that is executed if the build fails.</p>
</li>
<li>
<p><code>on-success.sh</code>: A script that is executed if the build succeeds.</p>
</li>
</ul>
<h3 id="bumping-pkgrel"><a class="header" href="#bumping-pkgrel">Bumping pkgrel</a></h3>
<p>This is now carried out by adding the required variable <code>CI_PACKAGE_BUMP</code> to <code>.CI/config</code>. See below for more
information.</p>
<h3 id="dependency-trees"><a class="header" href="#dependency-trees">Dependency trees</a></h3>
<p>The CI builds dependency trees automatically. They are passed to the Chaotic manager as a CI artifact and read whenever
a schedule command is being executed.
No manual intervention is needed.</p>
<h3 id="ciconfig"><a class="header" href="#ciconfig">.CI/config</a></h3>
<p>The <code>.CI/config</code> file inside each package directory contains additional flags to control the pipelines and build
processes with.</p>
<ul>
<li><code>CI_MANAGE_AUR</code>: By setting this variable to <code>true</code>, the CI will update the corresponding AUR repository at the end of
a
pipeline run if changes occur (omitting CI-related files)</li>
<li><code>CI_PACKAGE_BUMP</code>: Controls package bumps for all packages which don't have <code>CI_MANAGE_AUR</code> set to <code>true</code>. The format
this needs
to follow is either <code>1:1.2.3-1/1</code> (full current version and bump count after the slash) or <code>1.2.3</code> (full current
package version,
resolves to bump count <code>1</code>).</li>
<li><code>CI_PKGBUILD_SOURCE</code>: Sets the source for all PKGBUILD-related files, used for pulling updated files from remote
repositories.
Valid values as of now are:
<ul>
<li><code>gitlab</code>: Pulls the PKGBUILD from the GitLab repository tags. It needs to follow the format <code>gitlab:$PROJECT_ID</code>.
The ID can be obtained by browsing the repository settings general section.</li>
<li><code>aur</code>: Pulls the PKGBUILD from the AUR repository, pulling in the git repo and replacing the existing files with
the
new ones.</li>
</ul>
</li>
<li><code>CI_ON_TRIGGER</code>: Can be provided in case a special schedule trigger should schedule the corresponding package. This
can be used to schedule packages daily, by setting the value to <code>daily</code>.
Since this checks whether "$TRIGGER == $CI_ON_TRIGGER", any custom schedule can be created using pipeline schedules
and setting <code>TRIGGER</code> to <code>midnight</code>, adding a fitting schedule and setting <code>CI_ON_TRIGGER</code> for any affected package
to <code>midnight</code>.
Packages having this variable set will <strong>not</strong> be scheduled via the regular on-schedule pipeline, hence this one can
also be used to prevent wasting builder resources, e.g. useful for huge <code>-git</code> packages with a lot of commit activity,
like <code>llvm-git</code>.</li>
<li><code>CI_REBUILD_TRIGGERS</code>: Add packages known to be causing rebuilds to this variable. A list of repositories to track
package versions for is provided via the repositories' <code>CI_LIB_DB</code> parameter. Each package version is hashed and
dumped to <code>.ci/lib.state</code>. Each scheduled pipeline run compares versions by checking hash mismatches and will bump
each each affected package via <code>CI_PACKAGE_BUMP</code>.</li>
<li><code>BUILDER_CACHE_SOURCES</code>: Can be set to <code>true</code> in case the sources should be cached between builds. This can be useful
in case of slow sources or sources that are not available all the time. Sources will be cleared automatically after 1
month, which is important in case packages are getting removed or the source changes.</li>
</ul>
<h3 id="known-state-variables"><a class="header" href="#known-state-variables">Known state variables</a></h3>
<p>State will be kept in the .state worktree. It can be viewed by browsing the <code>state</code> branch of a PKGBUILD repository.
Each package will have their own file named after the package name. The following variables are known to be stored:</p>
<ul>
<li><code>CI_GIT_COMMIT</code>: Used by CI to determine whether the latest commit changed. Used by <code>fetch-gitsrc</code> to schedule new
builds. Needs to be provided in case the package should be treated as a git package. CI will automatically update the
latest available commit of the git URL set in the <code>source</code> section of the PKGBUILD. If it differs, schedule a
build. -<code>CI_PKGBUILD_TIMESTAMP</code>: The last modified date of the PKGBUILD on AUR. This is used to determine whether the
PKGBUILD has changed. If it differs, schedule a build. Will be maintained automatically.</li>
</ul>
<h3 id="ci-pipeline-variables"><a class="header" href="#ci-pipeline-variables">CI pipeline variables</a></h3>
<p>These variables can be set in in the repo root's<code>.ci/config</code> to configure the pipeline behavior globally as follows:</p>
<ul>
<li><code>BUILD_REPO</code>: The target repository that will be the deploy target</li>
<li><code>GIT_AUTHOR_EMAIL</code>: The email of the user that will be used to commit</li>
<li><code>GIT_AUTHOR_NAME</code>: The name of the user that will be used to commit</li>
<li><code>REDIS_SSH_HOST</code>: The Redis SSH host for the target repository (for SSH tunneling)</li>
<li><code>REDIS_SSH_PORT</code>: The Redis SSH port for the target repository (for SSH tunneling)</li>
<li><code>REDIS_SSH_USER</code>: The Redis SSH user for the target repository (for SSH tunneling)</li>
<li><code>REDIS_PORT</code>: The redis port for the target repository (inside the SSH tunnel)</li>
<li><code>REPO_NAME</code>: The name that this repository is referred to in Chaotic Manager's config</li>
<li><code>CI_HUMAN_REVIEW</code>: If merge/pull requests should be created for non pkgver changes</li>
<li><code>CI_MANAGE_AUR</code>: This should be set to true in case select AUR repositories should be managed by CI</li>
<li><code>CI_OVERWRITE_COMMITS</code>: If we should overwrite existing automated commits to reduce the size of the git history</li>
<li><code>CI_CLONE_DELAY</code>: How long to wait between every executed git clone command for rate limits</li>
<li><code>CI_AUR_PROXY</code>: Proxy to use for AUR requests</li>
</ul>
<h3 id="managing-aur-packages"><a class="header" href="#managing-aur-packages">Managing AUR packages</a></h3>
<p>AUR packages can also be managed via this repository in an automated way using <code>.CI_CONFIG</code>.
This means that after each scheduled and on-commit pipeline, the AUR repository will be updated to reflect the changes
done to the PKGBUILD folder's files.
Files not relevant to AUR maintenance (e.g. <code>.CI</code> folders) will be omitted.
The commit message reflects the fact that the commit was created by a CI pipeline
and contains the link to the source repository's commit history and the pipeline run which triggered the update commit.</p>
<h3 id="updating-the-cis-scripts"><a class="header" href="#updating-the-cis-scripts">Updating the CI's scripts</a></h3>
<p>This is done automatically via the CI pipeline. Once changes have been detected on the template repository, all files
will be updated to the current version.</p>
<h3 id="issues-and-pipeline-failures"><a class="header" href="#issues-and-pipeline-failures">Issues and pipeline failures</a></h3>
<h4 id="last-on-commit-pipeline-failed"><a class="header" href="#last-on-commit-pipeline-failed">Last on-commit pipeline failed</a></h4>
<p>This can happen in case of a few reasons, for example having provided an invalid package name. This causes
the <code>scheduled</code> tag to not be updated.
In this case, the on-schedule pipeline will not be able to run.
The last on-commit pipeline needs to be fixed before the on-schedule pipeline can run again.
Build failures however are not accounted as the <code>scheduled</code> tag would be updated already as soon as the scheduling
parameters were generated.
Force pushing a fixed up commit is actively encouraged in such a case, as pushing another commit will cause the CI to
evaluate the previous commits it missed, leading to noticing the same issue again and bailing out instead of silently
continuing.
This has been a design decision to prevent failures from being overlooked.</p>
<h4 id="resetting-the-build-queue"><a class="header" href="#resetting-the-build-queue">Resetting the build queue</a></h4>
<p>There might be rare cases in which a reset of the build queue is needed. This can be done by shutting down the central
Redis instance, removing its dump, and restarting its service.</p>
<h3 id="deploying-to-different-repos-using-the-same-infrastructure"><a class="header" href="#deploying-to-different-repos-using-the-same-infrastructure">Deploying to different repos using the same infrastructure</a></h3>
<p>This is now an officially supported use case. The only thing required is to use another repository that is going to
store PKGBUILDs and execute CI pipelines.
The environment variables passed to the main Chaotic Manager instance control which repositories are available to use
while scheduling packages. See below for more information.</p>
<h2 id="chaotic-manager"><a class="header" href="#chaotic-manager">Chaotic Manager</a></h2>
<p>This tool is distributed as Docker containers and consists of a pair of manager and builder instances.</p>
<ul>
<li>Manager: <code>registry.gitlab.com/garuda-linux/tools/chaotic-manager/manager</code>
<ul>
<li>Manages builds by adding them to the schedule, used e.g. in the schedule step of CI pipelines</li>
<li>Provides log management and the live-updating logs</li>
<li>Manages any existing builds by spinning up build containers, picking from the available BullMQ builder / database
queues</li>
<li>Picks up already built package archives from the landing zone (builder containers push finished build archives
here)
to add them to the database of the target repository</li>
</ul>
</li>
<li>Builder: <code>registry.gitlab.com/garuda-linux/tools/chaotic-manager/builder</code>
<ul>
<li>This one contains the actual logic behind package builds (
seen <a href="https://gitlab.com/garuda-linux/tools/chaotic-manager/-/tree/main/builder-container?ref_type=heads">here</a>)
known from infra 3.0 like <code>interfere.sh</code>, <code>database.sh</code> etc.</li>
<li>This one is used by an executing manager instance to run the build processes with. It runs jobs present in the
builder BullMQ queue.</li>
</ul>
</li>
</ul>
<p>An example of a valid config can be found in
the <a href="https://gitlab.com/garuda-linux/infra-nix/-/blob/main/docker-compose/chaotic-v4/docker-compose.yml?ref_type=heads#L38">Garuda Linux infrastructure repository</a>.
The following variables can be set in Docker environment:</p>
<ul>
<li><code>DATABASE_HOST</code>: database address published to the outside world</li>
<li><code>DATABASE_PORT</code>: the port behind packages can be deployed to</li>
<li><code>DATABASE_USER</code>: the user to use to deploy packages</li>
<li><code>GPG_PATH</code>: where the <code>.gnupg</code> folder resides (holding the key for signing packages)</li>
<li><code>LANDING_ZONE_PATH</code>: where the landing zone is (here packages get deployed and later picked up by the database job
before getting into the final repository)</li>
<li><code>LOGS_URL</code>: the URL that serves the logfiles (we get sent here when clicking CI's external stages)</li>
<li><code>PACKAGE_REPOS_NOTIFIERS</code>: needed configs to provide external CI stages for GitLab CI/GitHub Actions</li>
<li><code>PACKAGE_REPOS</code>: the source repositories containing PKGBUILD folders</li>
<li><code>PACKAGE_TARGET_REPOS</code>: the repository a package is getting deployed to (including its URL and extra keyrings/repos
needed)</li>
<li><code>REDIS_PASSWORD</code>: password for accessing the Redis instance</li>
<li><code>REDIS_SSH_HOST</code>: where to access the Redis instance</li>
<li><code>REDIS_SSH_USER</code>: the user who can access the Redis instance</li>
<li><code>REPO_PATH</code>: the path where the final package deployment happens</li>
<li><code>TELEGRAM_BOT_TOKEN</code>: the token for the Telegram bot, used for notifications</li>
<li><code>TELEGRAM_CHAT_ID</code>: the chat ID for the Telegram bot to send deployment or failure notifications to</li>
</ul>
<p>The following variables are only relevant for builder instances:</p>
<ul>
<li><code>BUILDER_HOSTNAME</code>: the hostname of the builder will be displayed in package logs to determine which builder built a
package</li>
<li><code>BUILDER_TIMEOUT</code>: the timeout for a package build, 3600 seconds by default. Should be increased on slow builders</li>
</ul>
<h3 id="setting-up"><a class="header" href="#setting-up">Setting up</a></h3>
<h4 id="requirements"><a class="header" href="#requirements">Requirements</a></h4>
<p>The base requirements for running this kind of setup are as follows:</p>
<ul>
<li>
<p>Docker/Podman must be installed in the target system, docker-/podman-compose are good to have as well. We will use it
in our following examples.</p>
</li>
<li>
<p>A Redis instance must be available, e.g. installed on the host system or added to ´docker-compose.yml`:</p>
<pre><code class="language-yml">chaotic-redis:
  image: redis:alpine
  container_name: chaotic-redis
  restart: always
  ports:
    - "6379:6379"
  command: redis-server --save 60 1 --loglevel warning --requirepass verysecurepassword
  volumes:
    - ./redis-data:/data
</code></pre>
<p>The following examples assume Redis to be installed on the host system. In case it is added to <code>docker-compose.yml</code>,
replace any occurances of <code>host.docker.internal</code> with <code>chaotic-redis</code>.</p>
</li>
<li>
<p>A reverse proxy like Nginx to expose the Chaotic Manager's logs to the public in a secure way should be available.
E.g., using Nginx it is sufficient to <code>proxy_pass</code> the specified <code>--web-port</code> value to the Manager instance container.
Additionally, the following settings might be usedful:</p>
<pre><code class="language-ǹginx">proxy_buffering off;
proxy_read_timeout 330s;
</code></pre>
</li>
</ul>
<h4 id="repository-setup"><a class="header" href="#repository-setup">Repository setup</a></h4>
<p>The repository needs to be derived from
the <a href="https://github.com/chaotic-cx/chaotic-repository-template">repository template</a>. On GitHub,
the <a href="https://github.com/new?template_name=chaotic-repository-template&amp;template_owner=chaotic-cx">"Use this template"</a>
feature may be used.
Afterward, customize the <code>.ci/config</code> file according to your needs. This file contains global configuration for pipeline
runs and CI behaviour.
The following options exist as of today:</p>
<ul>
<li><code>BUILD_REPO</code>: The target repository that will be the deploy target</li>
<li><code>GIT_AUTHOR_EMAIL</code>: The email of the user that will be used to commit</li>
<li><code>GIT_AUTHOR_NAME</code>: The name of the user that will be used to commit</li>
<li><code>REDIS_SSH_HOST</code>: The redis host for the target repository</li>
<li><code>REDIS_SSH_PORT</code>: The redis port for the target repository</li>
<li><code>REDIS_SSH_USER</code>: The redis user for the target repository</li>
<li><code>REDIS_PORT</code>: The redis port for the target repository</li>
<li><code>REPO_NAME</code>: The name that this repository is referred to in chaotic-manager's config</li>
<li><code>CI_HUMAN_REVIEW</code>: Whether merge/pull requests should be created for non pkgver changes (false/true)</li>
<li><code>CI_MANAGE_AUR</code>: This should be set to true in case select AUR repositories should be managed by CI. A fitting SSH key
needs to be deployed as AUR_KEY via secret CI variable.</li>
<li><code>CI_OVERWRITE_COMMITS</code>: Whether we should overwrite existing automated commits to reduce the size of the git history (
false/true)</li>
<li><code>CI_CLONE_DELAY</code>: How long to wait between every executed git clone command for ratelimits (false/true)</li>
<li><code>CI_AUR_PROXY</code>: Proxy to use for AUR requests</li>
<li><code>CI_LIB_DB</code>: Archlinux / Chaotic-AUR repo mirror to use for pulling db files from, in the following
format: <code>https://arch.mirror.constant.com/core/os/x86_64/core.db https://arch.mirror.constant.com/community/os/x86_64/community.db ...</code></li>
</ul>
<h4 id="exemplary-manager-instance-setup"><a class="header" href="#exemplary-manager-instance-setup">Exemplary manager instance setup</a></h4>
<pre><code class="language-yaml">chaotic-manager:
  image: registry.gitlab.com/garuda-linux/tools/chaotic-manager/manager:latest
  container_name: chaotic-manager
  command: database --web-port 8080
  environment:
    DATABASE_HOST: sub.domain.tld
    DATABASE_PORT: 22
    DATABASE_USER: package-deployer
    GPG_PATH: /var/awesome-repo/gnupg
    LANDING_ZONE_PATH: /var/awesome-repo/landing-zone
    LOGS_URL: https://sub.domain.tld/logs/logs.html
    REDIS_PASSWORD: verysecurepassword
    REDIS_SSH_HOST: host.docker.internal
    REDIS_SSH_USER: package-deployer
    REPO_PATH: /srv/http/repos
    TELEGRAM_BOT_TOKEN: 1234567890
    TELEGRAM_CHAT_ID: 0987654321
    PACKAGE_REPOS: &gt;-
      {
          "awesome-repo": {
              "url": "https://gitlab.com/awesome-repo/pkgbuilds"
          }
      }
    PACKAGE_TARGET_REPOS: &gt;-
      {
          "awesome-repo": {
              "extra_repos": [
                  {
                      "name": "awesome-repo",
                      "servers": [
                          "https://sub.domain.tld/awesome-repo/x86_64"
                      ]
                  }
              ],
              "extra_keyrings": [
                  "https://sub.domain.tld/awesome-repo/awesome-keyring.pkg.tar.zst"
              ]
          }
      }
    PACKAGE_REPOS_NOTIFIERS: &gt;-
      {
          "awesome-repo": {
              "id": "123456",
              "token": "GITLABAPITOKENWITHAPIACCESS",
              "check_name": "awesome-repo: %pkgbase%"
          }
      }
  volumes:
    - ./sshkey:/app/sshkey
    - /var/run/docker.sock:/var/run/docker.sock
    - /srv/http/repos:/repo_root
  extra_hosts:
    - "host.docker.internal:host-gateway"
  ports: [8080:8080]
</code></pre>
<p>The following things are to note:</p>
<ul>
<li><code>PACKAGE_REPOS</code>, <code>PACKAGE_TARGET_REPOS</code> and <code>PACKAGE_REPOS_NOTIFIERS</code> are JSON values and need to be valid JSON in
order to be processed.</li>
<li>The above setup assumes the docker-compose.yml to be present in <code>var/awesome-repo</code>.</li>
<li><code>LOGS_URL</code> needs to match the address which the reverse proxy publishes <code>--web-port 8080</code> to the outside world.</li>
<li><code>REPO_PATH</code> is the path of the repository <em>on the Docker host</em>. The same path must be mapped to <code>/repo_root</code> inside
the container via volumes.</li>
<li><code>/app/sshkey</code> is assumed to be the private SSH key</li>
<li>Ports don't have to explicitly exposed if using an Nginx Docker container, in this setup however, our Nginx and Redis
instance are present on the host system.</li>
<li><code>PACKAGE_REPOS_NOTIFIERS</code> and <code>TELEGRAM_*</code> variables are optional but provide additional functionality of they are
set.</li>
<li><code>DATABASE_HOST</code> refers to the address published to the outside world, e.g. for additional builders an other servers.</li>
</ul>
<h4 id="examplary-builder-instance-setup"><a class="header" href="#examplary-builder-instance-setup">Examplary builder instance setup</a></h4>
<pre><code class="language-yaml">---
services:
  chaotic-builder:
    image: registry.gitlab.com/garuda-linux/tools/chaotic-manager/manager:latest
    container_name: chaotic-builder
    command: builder
    environment:
      BUILDER_TIMEOUT: 7200
      BUILDER_HOSTNAME: awesome-builder
      REDIS_PASSWORD: verysecurepassword
      REDIS_SSH_HOST: host.docker.internal
      REDIS_SSH_USER: package-deployer
      SHARED_PATH: /var/chaotic/shared
      DATABASE_HOST: host.docker.internal
      DATABASE_PORT: 22
    volumes:
      - ./shared:/shared
      - ./sshkey:/app/sshkey
      - /var/run/docker.sock:/var/run/docker.sock
    extra_hosts:
      - "host.docker.internal:host-gateway"
</code></pre>
<p>The following things are to note:</p>
<ul>
<li>The above setup assumes the docker-compose.yml to be present in <code>var/awesome-repo</code>.</li>
<li>The <code>SHARED_PATH</code> variable needs to match the directory mapped to <code>/shared</code> inside the container.</li>
<li><code>DATABASE_HOST</code> can in theory be any other host, but can be set to <code>host.docker.internal</code> in case the Redis instance
runs on the Docker host.</li>
<li>The Docker socket needs to be mounted as the builder instance will use it to spin up build container instances.</li>
<li><code>/app/sshkey</code> is assumed to be the private SSH key used for pushing finished package builds to the manager instance's
landing zone.</li>
<li><code>BUILDER_TIMEOUT</code> only needs to be set in case it is a slower build machine which does not finish heaver tasks in one
hour.</li>
<li>As many instances of this container can be added the setup as wanted. Each of them will allow processing another build
at the same time in total.</li>
</ul>
<h3 id="features"><a class="header" href="#features">Features</a></h3>
<h4 id="chaotic-manager-container-commands"><a class="header" href="#chaotic-manager-container-commands">Chaotic-Manager container commands</a></h4>
<ul>
<li><code>schedule</code>: Schedules a new package build by adding it to the Redis instance. It takes the following arguments:
<ul>
<li><code>arch</code>: The architecture to build the package for</li>
<li><code>target-repo</code>: The target repository to deploy the package to, referring to the <code>PACKAGE_TARGET_REPOS</code> variable
set
in the Docker environment variables.</li>
<li><code>source-repo</code>: The source repository to pull the package from, referring to the <code>PACKAGE_REPOS</code> variable set in
the
Docker environment variables.</li>
<li><code>commit</code>: The commit hash which the schedule call originates from</li>
<li><code>deptree</code>: the dependency tree built by the CI pipeline. This parameter is omitted in CI pipelines and instead
passed as file, reading from <code>/.ci/deptree.txt</code>. The reason is that the parameter will be to huge to be processed
by
the shell if 100+ packages are
scheduled at the same time.
It contains information about the build order of packages and their dependencies.</li>
</ul>
</li>
<li><code>builder</code>: Starts the build job, which then grabs any available build jobs from the build queue.</li>
<li><code>auto-repo-remove</code>: Removes obsolete packages from the target repository. Further parameters must include the pkgbases
to be removed.</li>
<li><code>database</code>: Starts the manager instance, which is responsible for managing queues, logs and database jobs. It
additionally spins up a web server to serve logs from if <code>--web-port</code> is passed as argument.</li>
<li><code>web</code>: Starts the web server to serve logs from. This is only needed in case the manager instance does not run the web
server.</li>
</ul>
<h4 id="web-server"><a class="header" href="#web-server">Web server</a></h4>
<p>Available routes on the port set up be the <code>--web-port</code> parameter are as follows:</p>
<ul>
<li><code>/api/logs/:id/:timestamp</code>: Returns the log file of a package build. The <code>id</code> is the package's ID, the <code>timestamp</code> is
the timestamp of the build.</li>
<li><code>/api/logs/:id</code>: Returns the latest log file of a package build. The <code>id</code> is the package's ID.</li>
<li><code>/api/queue/stats</code>: Returns a JSON object containing the current queue stats.</li>
<li><code>/api/queue/packages</code>: Returns a JSON object containing information the currently scheduled packages.</li>
<li><code>/metrics</code>: Returns collected Prometheus metrics.</li>
</ul>
<h4 id="notifications"><a class="header" href="#notifications">Notifications</a></h4>
<p>Notifications about relevant events can be sent to a Telegram channel or chat via a Bot.
This requires a valid Bot token and the Chat ID to be set.
The following events are currently supported:</p>
<ul>
<li>
<p>Build failures: additionally contains links to full build logs and the originating commit.</p>
<pre><code class="language-text">🚨 Failed deploying to awesome-repo:
&gt; freecad-git - logs- commit
</code></pre>
</li>
<li>
<p>Build success:</p>
<pre><code class="language-text">📣 New deployment to awesome-repo:
&gt; freecad-git
</code></pre>
</li>
<li>
<p>Timed out build: Contains links to full build logs and the originating commit.</p>
<pre><code class="language-text">⏳ Build for awesome-repo failed due to a timeout:
&gt; freecad-git - logs - commit
</code></pre>
</li>
<li>
<p>Successful repo-remove jobs:</p>
<pre><code class="language-text">✅ Repo-remove job for awesome-repo finished successfully
</code></pre>
</li>
<li>
<p>Failed repo-remove jobs:</p>
<pre><code class="language-text">🚫 Repo-remove job for awesome-repo failed
</code></pre>
</li>
</ul>
<h4 id="build-order"><a class="header" href="#build-order">Build order</a></h4>
<p>The build order is determined by the dependency tree built by the CI pipeline.
This tree is passed to the manager and is then used to determine the correct build order automatically.
No further intervention is needed to achieve this.</p>
<h4 id="live-updating-logs"><a class="header" href="#live-updating-logs">Live-updating logs</a></h4>
<p>Logs are live-updating and can be viewed in real-time via the web server.
In case GitLab is used and <code>PACKAGE_REPOS_NOTIFIERS</code> is set,
an external CI stage will be created for every package scheduled during the CI run, linking to the log.</p>
<h4 id="prometheus-metrics"><a class="header" href="#prometheus-metrics">Prometheus metrics</a></h4>
<p>Prometheus metrics are available at the <code>/metrics</code> endpoint of the web server.
Currently, we collect default <code>prom-client</code> metrics as well as statistics about total event count of each build status
(failed, successful, already-built, timed out) as well as metrics about overall build times.
These can be collected via a Prometheus instance and then be visualized using Grafana.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="discourse"><a class="header" href="#discourse">Discourse</a></h1>
<p>Discourse is the application we use to host our forum.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="documentation"><a class="header" href="#documentation">Documentation</a></h1>
<h2 id="building-it"><a class="header" href="#building-it">Building it</a></h2>
<p>The documentation is created by using <a href="https://rust-lang.github.io/mdBook/index.html">mdBook</a>, which generates Markdown files and generates HTML pages for them. The documentation can be build by running:</p>
<pre><code class="language-sh">nix build .#docs # plain simple
</code></pre>
<p>The files can then be found at <code>./result/</code>, which is a symlink to the corresponding path in <code>/nix/store</code>.
mdBook is also able to automatically serve the current content and update it automatically whenever a change is detected.
This makes testing and previewing content easy.</p>
<pre><code class="language-sh">mdbook serve --open # the latter additionally opens the website in a browser
</code></pre>
<h2 id="useful-information"><a class="header" href="#useful-information">Useful information</a></h2>
<h3 id="mdbook-syntax"><a class="header" href="#mdbook-syntax">mdBook syntax</a></h3>
<p>While the general syntax for writing Markdown applies to mdBook, it has several extensions beyond the standard CommonMark specification.</p>
<ul>
<li><a href="https://rust-lang.github.io/mdBook/format/markdown.html">Markdown syntax</a></li>
<li><a href="https://rust-lang.github.io/mdBook/format/mdbook.html">mdBook specific features</a></li>
</ul>
<p>Especially importing code blocks as Markdown is really handy to keep content always up-to-date and helps providing a full text searchable code documentation.</p>
<h3 id="updating-mdbook-plugins-contents"><a class="header" href="#updating-mdbook-plugins-contents">Updating mdBook plugins contents</a></h3>
<p>Some of the mdBook parts are plugins that need their content to be updated from time to time. Namely, thats:</p>
<ul>
<li>mdbook-admonish: run <code>mdbook-admonish</code> inside the <code>docs</code> folder</li>
<li>mdbook-emojicodes: works without CSS, so no updates needed</li>
<li>mdbook-catppuccin: run <code>mdbook-catppuccin</code> inside the <code>docs</code> folder (might need to grab binary from <a href="https://github.com/catppuccin/mdBook/releases">its website</a>, no Nix package available yet)</li>
</ul>
<h2 id="deployment"><a class="header" href="#deployment">Deployment</a></h2>
<p>Deployment to Cloudflare pages automated and happens whenever a commit to main occurs.
A <a href="https://github.com/garuda-linux/infrastructure-nix/blob/main/.github/workflows/pages.yml">GitHub actions workflow</a> builds and pushes it to the <code>cf-pages</code> branch, which will then be used by the Cloudflare pages app to deploy the new version from.</p>
<pre><code class="language-yaml">---
name: Cloudflare pages
on:
  push:
    branches: [main]
    paths: [docs/**, README.md]
permissions:
  contents: write
jobs:
  build-and-deploy:
    concurrency: ci-${{ github.ref }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout 🛎️
        uses: actions/checkout@v4
      - name: Setup mdBook 📜
        uses: peaceiris/actions-mdbook@v2
        with:
          mdbook-version: latest
      - name: Install further deps 📦
        run: |
          sudo apt-get install -y --no-install-recommends cargo
          cargo install mdbook-admonish
          cargo install mdbook-emojicodes
          PATH=$HOME/.cargo/bin:$PATH
      - name: Install and Build 🔧
        run: cd docs &amp;&amp; mdbook build
      - name: Deploy 🚀
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_branch: cf-pages
          publish_dir: docs/book
</code></pre>
<h2 id="issues-and-their-solution-1"><a class="header" href="#issues-and-their-solution-1">Issues and their solution</a></h2>
<h3 id="sidebar-or-something-else-on-the-documentation-doesnt-work-as-expected"><a class="header" href="#sidebar-or-something-else-on-the-documentation-doesnt-work-as-expected">Sidebar or something else on the documentation doesn't work as expected</a></h3>
<p>Chances are that the custom CSS parts need to be rebased to a newer version.
They can be found in <code>./docs/theme/css</code> and the only addition we made here is to use the Fira Sans font instead of the default one.
To rebase against a newer version comment out <code>dditional-css</code> in <code>./docs/book.toml</code> and move the <code>css</code> folder somewhere else temporarily.
After that, run <code>mdbook build</code> inside the <code>docs</code> folder. The new CSS files can now be found inside the <code>./docs/book/css</code> folder.
Copy those to the <code>./docs/theme/css</code> folder and alter the occurrences of font settings to include Fira Sans (or run a diff to find out where).
After uncommenting <code>additional-css</code> in <code>book.toml</code>, run <code>mdbook build</code> again to verify nothing got broken along the way.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tailscale"><a class="header" href="#tailscale">Tailscale</a></h1>
<p>Our current access policies look as follows:</p>
<pre><code class="language-json">// This tailnet's ACLs are maintained in https://gitlab.com/garuda-linux/infra-nix
{
	// Define access control lists for users, groups, autogroups, tags,
	// Tailscale IP addresses, and subnet ranges
	"acls": [
		// All servers can connect to each other, use exit nodes and oracle-dragon as DNS
		{
			"action": "accept",
			"src":    ["tag:infra"],
			"dst":    ["tag:infra:*", "autogroup:internet:*", "100.86.102.115:*"],
		},
		// Tailscale admins can access every device
		{
			"action": "accept",
			"src":    ["autogroup:admin"],
			"dst":    ["*:*"],
		},
		// Shared out nodes can be accessed on SSH / Mosh ports
		{
			"action": "accept",
			"src":    ["autogroup:shared"],
			"dst":    ["*:22,222-230,666,60000-61000"],
		},
		// Let the chaotic nodes connect to chaotic-v4's Redis (build distribution)
		{
			"action": "accept",
			"src":    ["tag:chaotic-node"],
			"dst":    ["100.75.227.149:22,6379"],
		},
	],
	// Current infra maintainers
	"groups": {
		"group:admins": ["dr460nf1r3@github", "JustTNE@github"],
	},
	// Define a tag to use as destinations
	"tagOwners": {
		// Admins may apply the "infra" tag
		"tag:infra":        ["group:admins"],
		"tag:chaotic-node": ["group:admins"],
	},
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="garuda-linux-code-of-conduct"><a class="header" href="#garuda-linux-code-of-conduct">Garuda Linux Code of Conduct</a></h1>
<p>Thank you for being a part of the Garuda Linux community. We value your participation and want everyone to have an enjoyable and fulfilling experience. Accordingly, all participants are expected to follow this Code of Conduct, and to show respect, understanding, and consideration to one another. Thank you for helping make this a welcoming, friendly community for everyone.</p>
<h2 id="scope"><a class="header" href="#scope">Scope</a></h2>
<p>This Code of Conduct applies to all Garuda Linux community spaces, including, but not limited to:</p>
<ul>
<li>Code repositories - <code>gitlab.com/garuda-linux</code> and <code>github.com/garuda-linux</code></li>
<li>Garuda Linux's Telegram channels and groups (including bridges to Matrix)</li>
<li>Mailing <code>*@garudalinux.org</code></li>
<li>Community spaces hosted on <code>garudalinux.org</code> infrastructure</li>
</ul>
<p>Communication channels and private conversations that are normally out of scope may be considered in scope if a Garuda Linux participant is being stalked or harassed. Social media conversations may be considered in-scope if the incident occurred under a Garuda Linux related hashtag, or when an official Garuda Linux account on social media is tagged, or within any other discussion about Garuda Linux. The Garuda Linux's staff reserves the right to take actions against behaviors that happen in any context, if they are deemed to be relevant to the Garuda Linux project and its participants.</p>
<p>All participants in Garuda Linux community spaces are subject to the Code of Conduct. This includes founding members, staff members, corporate sponsors, and paid employees. This also includes volunteers, maintainers, leaders, contributors, contribution reviewers, issue reporters, Garuda Linux users, and anyone participating in discussion in Garuda Linux community spaces.</p>
<h2 id="reporting-an-incident"><a class="header" href="#reporting-an-incident">Reporting an Incident</a></h2>
<p>If you believe that someone is violating the Code of Conduct, or have any other concerns, please contact <a href="mailto:team@garudalinux.org">team@garudalinux.org</a>.</p>
<h2 id="our-standards"><a class="header" href="#our-standards">Our Standards</a></h2>
<p>The Garuda Linux community is dedicated to providing a positive experience for everyone, regardless of:</p>
<ul>
<li>age</li>
<li>body size</li>
<li>caste</li>
<li>citizenship</li>
<li>disability</li>
<li>education</li>
<li>ethnicity</li>
<li>familial status</li>
<li>gender expression</li>
<li>gender identity</li>
<li>genetic information</li>
<li>immigration status</li>
<li>level of experience</li>
<li>nationality</li>
<li>personal appearance</li>
<li>pregnancy</li>
<li>race</li>
<li>religion</li>
<li>sex characteristics</li>
<li>sexual orientation</li>
<li>sexual identity</li>
<li>socio-economic status</li>
<li>tribe</li>
<li>veteran status</li>
</ul>
<h2 id="community-guidelines"><a class="header" href="#community-guidelines">Community Guidelines</a></h2>
<p>Behaviors that contribute to creating a positive environment include:</p>
<ul>
<li><strong>Be friendly.</strong> Use welcoming and inclusive language.</li>
<li><strong>Be empathetic.</strong> Be respectful of others' viewpoints and experiences.</li>
<li><strong>Be respectful.</strong> Express disagreements in a polite and constructive manner.</li>
<li><strong>Be considerate.</strong> Focus on what is best for the community. Keep discussions around technology choices constructive and respectful. Remember that decisions are often a difficult choice between competing priorities.</li>
<li><strong>Be patient and generous.</strong> If someone asks for help, it is because they need it. When documentation is available that answers the question, politely point them to it. If the question is off-topic, suggest a more appropriate online space to seek help.</li>
<li><strong>Try to be concise.</strong> Read the discussion before commenting in order to not repeat a point that has been made.</li>
</ul>
<h2 id="inappropriate-behavior"><a class="header" href="#inappropriate-behavior">Inappropriate Behavior</a></h2>
<p>We want all participants in the Garuda Linux community have the best possible experience they can. Community members asked to stop any inappropriate behavior are expected to comply immediately.</p>
<p>Inappropriate behaviors include, but are not limited to:</p>
<ul>
<li><strong>Deliberate intimidation, stalking, or following.</strong></li>
<li><strong>Sustained disruption of online discussion, talks, or other events.</strong> Sustained disruption of events, online discussions, or meetings, including talks and presentations, will not be tolerated. This includes 'Talking over' or 'heckling' event speakers or influencing crowd actions that cause hostility in event sessions. Sustained disruption also includes drinking alcohol to excess or using recreational drugs to excess, or pushing others to do so.</li>
<li><strong>Harassment of people who don't drink alcohol or other legal substances.</strong> We do not tolerate derogatory comments about those who abstain from alcohol or other legal substances. We do not tolerate pushing people to drink, talking about their abstinence or preferences to others, or pressuring them to drink - physically or through jeering.</li>
<li><strong>Sexist, racist, homophobic, transphobic, ableist language or otherwise exclusionary language.</strong> This includes deliberately referring to someone by a gender that they do not identify with, and/or questioning the legitimacy of an individual's gender identity. If you're unsure if a word is derogatory, don't use it. This also includes repeated subtle and/or indirect discrimination.</li>
<li><strong>Unwelcome sexual attention or behavior that contributes to a sexualized environment.</strong> This includes sexualized comments, jokes or imagery in interactions, communications or presentation materials, as well as inappropriate touching, groping, or sexual advances. Sponsors should not use sexualized images, activities, or other material. Meetup organizing staff and other volunteer organizers should not use sexualized clothing/uniforms/costumes, or otherwise create a sexualized environment.</li>
<li><strong>Unwelcome physical contact.</strong> This includes touching a person without permission, including sensitive areas such as their hair, pregnant stomach, mobility device (wheelchair, scooter, etc) or tattoos. This also includes physically blocking or intimidating another person. Physical contact without affirmative consent is not acceptable. This includes sharing or distribution of sexualized images or text.</li>
<li><strong>Violence or threats of violence.</strong> Violence and threats of violence are not acceptable - online or offline. This includes incitement of violence toward any individual, including encouraging a person to commit self-harm. This also includes posting or threatening to post other people's personally identifying information ("doxxing") online.</li>
<li><strong>Influencing or encouraging inappropriate behavior.</strong> If you influence or encourage another person to violate the Code of Conduct, you may face the same consequences as if you had violated the Code of Conduct.</li>
</ul>
<h3 id="safety-versus-comfort"><a class="header" href="#safety-versus-comfort">Safety versus Comfort</a></h3>
<p>The Garuda Linux community prioritizes marginalized people's safety over privileged people's comfort. The following are not against the Code of Conduct.</p>
<ul>
<li>"Reverse"-isms, including "reverse racism," "reverse sexism," and "cisphobia"</li>
<li>Reasonable communication of boundaries, such as "leave me alone," "go away," or "I'm not discussing this with you."</li>
<li>Criticizing racist, sexist, cissexist, or otherwise oppressive behavior or assumptions</li>
<li>Communicating boundaries or criticizing oppressive behavior in a "tone" you don't find congenial</li>
</ul>
<p>If you have questions about the above statements, please read <a href="https://wiki.gnome.org/Foundation/CodeOfConduct/SupportingDiversity">GNOME Foundation's document on Supporting Diversity</a>.</p>
<p>Outreach and diversity efforts directed at under-represented groups are permitted under the code of conduct. For example, a social event for women would not be classified as being outside the Code of Conduct under this provision.</p>
<p>Basic expectations for conduct are not covered by the "reverse-ism clause" and would be enforced irrespective of the demographics of those involved. For example, racial discrimination will not be tolerated, irrespective of the race of those involved. Nor would unwanted sexual attention be tolerated, whatever someone's gender or sexual orientation. Members of our community have the right to expect that participants in the project will uphold these standards.</p>
<p>If a participant engages in behavior that violates this code of conduct, the Garuda Linux's staff may take any action they deem appropriate. In cases involving the staff or founding members the immediate action is expelishment.</p>
<h2 id="procedure-for-handling-incidents"><a class="header" href="#procedure-for-handling-incidents">Procedure for Handling Incidents</a></h2>
<p>You can make a report by emailing <a href="mailto:team@garudalinux.org">team@garudalinux.org</a>.</p>
<p>If you make a report via email, we hope you can provide us with some information that will help us identify the reported person. If you don’t remember all the details, we still encourage you to make a report.</p>
<p>We encourage you to include the following information in your report:</p>
<ul>
<li>Your contact info (so we can get in touch with you if we need to follow up)</li>
<li>Date and time of the incident</li>
<li>Whether the incident is ongoing</li>
<li>Which online community and which part of the online community space it occurred in</li>
<li>Description of the incident</li>
<li>Identifying information of the reported person such as name, online username, handle, email address, or IP address</li>
<li>A link to the conversation</li>
<li>Any logs or screenshots of the conversation</li>
<li>Additional circumstances surrounding the incident</li>
<li>Other people involved in or witnesses to the incident and their contact information or # Garuda Linux Code of Conduct</li>
</ul>
<p>Thank you for being a part of the Garuda Linux community. We value your participation and want everyone to have an enjoyable and fulfilling experience.
Accordingly, all participants are expected to follow this Code of Conduct, and to show respect, understanding, and consideration to one another.
Thank you for helping make this a welcoming, friendly community for everyone.</p>
<h2 id="scope-1"><a class="header" href="#scope-1">Scope</a></h2>
<p>This Code of Conduct applies to all Garuda Linux community spaces, including, but not limited to:</p>
<ul>
<li>Code repositories - <code>gitlab.com/garuda-linux</code> and <code>github.com/garuda-linux</code></li>
<li>Garuda Linux's Telegram channels and groups (including bridges to Matrix)</li>
<li>Mailing <code>*@garudalinux.org</code></li>
<li>Community spaces hosted on <code>garudalinux.org</code> infrastructure</li>
</ul>
<p>Communication channels and private conversations that are normally out of scope may be considered in scope if a Garuda Linux participant is being stalked or harassed.
Social media conversations may be considered in-scope if the incident occurred under a Garuda Linux related hashtag, or when an official Garuda Linux account on social media is tagged, or within any other discussion about Garuda Linux.
The Garuda Linux's staff reserves the right to take actions against behaviors that happen in any context, if they are deemed to be relevant to the Garuda Linux project and its participants.</p>
<p>All participants in Garuda Linux community spaces are subject to the Code of Conduct. This includes founding members, staff members, corporate sponsors, and paid employees.
This also includes volunteers, maintainers, leaders, contributors, contribution reviewers, issue reporters, Garuda Linux users, and anyone participating in discussion in Garuda Linux community spaces.</p>
<h2 id="reporting-an-incident-1"><a class="header" href="#reporting-an-incident-1">Reporting an Incident</a></h2>
<p>If you believe that someone is violating the Code of Conduct, or have any other concerns, please contact <a href="mailto:team@garudalinux.org">team@garudalinux.org</a>.</p>
<h2 id="our-standards-1"><a class="header" href="#our-standards-1">Our Standards</a></h2>
<p>The Garuda Linux community is dedicated to providing a positive experience for everyone, regardless of:</p>
<ul>
<li>age</li>
<li>body size</li>
<li>caste</li>
<li>citizenship</li>
<li>disability</li>
<li>education</li>
<li>ethnicity</li>
<li>familial status</li>
<li>gender expression</li>
<li>gender identity</li>
<li>genetic information</li>
<li>immigration status</li>
<li>level of experience</li>
<li>nationality</li>
<li>personal appearance</li>
<li>pregnancy</li>
<li>race</li>
<li>religion</li>
<li>sex characteristics</li>
<li>sexual orientation</li>
<li>sexual identity</li>
<li>socio-economic status</li>
<li>tribe</li>
<li>veteran status</li>
</ul>
<h2 id="community-guidelines-1"><a class="header" href="#community-guidelines-1">Community Guidelines</a></h2>
<p>Behaviors that contribute to creating a positive environment include:</p>
<ul>
<li><strong>Be friendly.</strong> Use welcoming and inclusive language.</li>
<li><strong>Be empathetic.</strong> Be respectful of others' viewpoints and experiences.</li>
<li><strong>Be respectful.</strong> Express disagreements in a polite and constructive manner.</li>
<li><strong>Be considerate.</strong> Focus on what is best for the community. Keep discussions around technology choices constructive and respectful.<br />
Remember that decisions are often a difficult choice between competing priorities.</li>
<li><strong>Be patient and generous.</strong> If someone asks for help, it is because they need it.
When documentation is available that answers the question, politely point them to it. If the question is off-topic, suggest a more appropriate online space to seek help.</li>
<li><strong>Try to be concise.</strong> Read the discussion before commenting in order to not repeat a point that has been made.</li>
</ul>
<h2 id="inappropriate-behavior-1"><a class="header" href="#inappropriate-behavior-1">Inappropriate Behavior</a></h2>
<p>We want all participants in the Garuda Linux community have the best possible experience they can. Community members asked to stop any inappropriate behavior are expected to comply immediately.</p>
<p>Inappropriate behaviors include, but are not limited to:</p>
<ul>
<li><strong>Deliberate intimidation, stalking, or following.</strong></li>
<li><strong>Sustained disruption of online discussion, talks, or other events.</strong> Sustained disruption of events, online discussions, or meetings, including talks and presentations, will not be tolerated.
This includes 'Talking over' or 'heckling' event speakers or influencing crowd actions that cause hostility in event sessions.
Sustained disruption also includes drinking alcohol to excess or using recreational drugs to excess, or pushing others to do so.</li>
<li><strong>Harassment of people who don't drink alcohol or other legal substances.</strong> We do not tolerate derogatory comments about those who abstain from alcohol or other legal substances.
We do not tolerate pushing people to drink, talking about their abstinence or preferences to others, or pressuring them to drink - physically or through jeering.</li>
<li><strong>Sexist, racist, homophobic, transphobic, ableist language or otherwise exclusionary language.</strong> This includes deliberately referring to someone by a gender that they do not identify with, and/or
questioning the legitimacy of an individual's gender identity.
If you're unsure if a word is derogatory, don't use it. This also includes repeated subtle and/or indirect discrimination.</li>
<li><strong>Unwelcome sexual attention or behavior that contributes to a sexualized environment.</strong> This includes sexualized comments, jokes or imagery in interactions, communications or presentation materials, as well as inappropriate touching, groping, or sexual advances. Sponsors should not use sexualized images, activities, or other material. Meetup organizing staff and other volunteer organizers should not use sexualized clothing/uniforms/costumes, or otherwise create a sexualized environment.</li>
<li><strong>Unwelcome physical contact.</strong> This includes touching a person without permission, including sensitive areas such as their hair, pregnant stomach, mobility device (wheelchair, scooter, etc) or tattoos. This also includes physically blocking or intimidating another person. Physical contact without affirmative consent is not acceptable. This includes sharing or distribution of sexualized images or text.</li>
<li><strong>Violence or threats of violence.</strong> Violence and threats of violence are not acceptable - online or offline. This includes incitement of violence toward any individual, including encouraging a person to commit self-harm. This also includes posting or threatening to post other people's personally identifying information ("doxxing") online.</li>
<li><strong>Influencing or encouraging inappropriate behavior.</strong> If you influence or encourage another person to violate the Code of Conduct, you may face the same consequences as if you had violated the Code of Conduct.</li>
</ul>
<h3 id="safety-versus-comfort-1"><a class="header" href="#safety-versus-comfort-1">Safety versus Comfort</a></h3>
<p>The Garuda Linux community prioritizes marginalized people's safety over privileged people's comfort. The following are not against the Code of Conduct.</p>
<ul>
<li>"Reverse"-isms, including "reverse racism," "reverse sexism," and "cisphobia"</li>
<li>Reasonable communication of boundaries, such as "leave me alone," "go away," or "I'm not discussing this with you."</li>
<li>Criticizing racist, sexist, cissexist, or otherwise oppressive behavior or assumptions</li>
<li>Communicating boundaries or criticizing oppressive behavior in a "tone" you don't find congenial</li>
</ul>
<p>If you have questions about the above statements, please read <a href="https://wiki.gnome.org/Foundation/CodeOfConduct/SupportingDiversity">GNOME Foundation's document on Supporting Diversity</a>.</p>
<p>Outreach and diversity efforts directed at under-represented groups are permitted under the code of conduct. For example, a social event for women would not be classified as being outside the Code of Conduct under this provision.</p>
<p>Basic expectations for conduct are not covered by the "reverse-ism clause" and would be enforced irrespective of the demographics of those involved. For example, racial discrimination will not be tolerated, irrespective of the race of those involved. Nor would unwanted sexual attention be tolerated, whatever someone's gender or sexual orientation. Members of our community have the right to expect that participants in the project will uphold these standards.</p>
<p>If a participant engages in behavior that violates this code of conduct, the Garuda Linux's staff may take any action they deem appropriate. In cases involving the staff or founding members the immediate action is expelishment.</p>
<h2 id="procedure-for-handling-incidents-1"><a class="header" href="#procedure-for-handling-incidents-1">Procedure for Handling Incidents</a></h2>
<p>You can make a report by emailing <a href="mailto:team@garudalinux.org">team@garudalinux.org</a>.</p>
<p>If you make a report via email, we hope you can provide us with some information that will help us identify the reported person. If you don’t remember all the details, we still encourage you to make a report.</p>
<p>We encourage you to include the following information in your report:</p>
<ul>
<li>Your contact info (so we can get in touch with you if we need to follow up)</li>
<li>Date and time of the incident</li>
<li>Whether the incident is ongoing</li>
<li>Which online community and which part of the online community space it occurred in</li>
<li>Description of the incident</li>
<li>Identifying information of the reported person such as name, online username, handle, email address, or IP address</li>
<li>A link to the conversation</li>
<li>Any logs or screenshots of the conversation</li>
<li>Additional circumstances surrounding the incident</li>
<li>Other people involved in or witnesses to the incident and their contact information or description</li>
</ul>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>The Garuda Linux Code of Conduct is licensed under a <a href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution Share-Alike 3.0 Unported License</a>.</p>
<p><img src="https://licensebuttons.net/l/by-sa/3.0/88x31.png" alt="Creative Commons License" /></p>
<h2 id="attribution"><a class="header" href="#attribution">Attribution</a></h2>
<p>The Garuda Linux Code of Conduct was forked from GNOME Foundation's Code of Conduct (last modified 2020-10-01), which is under a Creative Commons license. See the <a href="https://web.archive.org/web/20210813233606/https://wiki.gnome.org/Foundation/CodeOfConduct">original page</a> for the original attributions.
description</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="privacy-policy-for-garuda-linux"><a class="header" href="#privacy-policy-for-garuda-linux">Privacy policy for Garuda Linux</a></h1>
<h2 id="about-this-document"><a class="header" href="#about-this-document">About this document</a></h2>
<p>This Privacy Policy governs the manner in which Garuda Linux collects, uses, maintains and discloses information collected from users (each, a “User”) of our website and web services..</p>
<h2 id="what-information-do-we-collect"><a class="header" href="#what-information-do-we-collect">What information do we collect?</a></h2>
<p>We collect information from you when you register on our site and gather data when you participate in the forum by reading, writing, and evaluating the content shared here.</p>
<p>When registering on our site, you may be asked to enter your name and e-mail address. You may, however, visit our site without registering. Your e-mail address will be verified by an email containing a unique link. If that link is visited, we know that you control the e-mail address. Your IP address will be checked against a database of known spammers to prevent such actions.</p>
<p>If you contact us directly, we may receive additional information about you such as your name, email address, the contents of the message and/or attachments you may send us, and any other information you may choose to provide.</p>
<p>When registered and posting, we record the IP address that the post originated from. We also may retain server logs which include the IP address of every request to our server, which will be purged after 30 days.</p>
<h2 id="what-do-we-use-your-information-for"><a class="header" href="#what-do-we-use-your-information-for">What do we use your information for?</a></h2>
<p>Any of the information we collect from you may be used in one of the following ways:</p>
<ul>
<li>To provide, operate, and maintain our infrastructure</li>
<li>To allow using our services that require a login, as well as to provide convenience features such as staying logged in or keeping personally chosen settings.</li>
<li>To send periodic emails that are generated by our services such as the forum, which may however be turned off if desired.</li>
</ul>
<p>We have no interest in your data and only store the minimum needed to operate the services we provide to our users.</p>
<h2 id="how-do-we-protect-your-information"><a class="header" href="#how-do-we-protect-your-information">How do we protect your information?</a></h2>
<p>We implement a variety of security measures to maintain the safety of your personal information when you enter, submit, or access your personal information.</p>
<h2 id="what-is-your-data-retention-policy"><a class="header" href="#what-is-your-data-retention-policy">What is your data retention policy?</a></h2>
<p>We will make a good faith effort to:</p>
<ul>
<li>Retain server logs containing the IP address of all requests to this server no more than 90 days.</li>
<li>Retain the IP addresses associated with registered users and their posts no more than 5 years.</li>
</ul>
<h2 id="third-party-privacy-policies"><a class="header" href="#third-party-privacy-policies">Third Party Privacy Policies</a></h2>
<p>Garuda Linux's Privacy Policy does not apply to some of the services we utilize in our infrastructure. Thus, we are advising you to consult the respective Privacy Policies of these third-party services for more detailed information.</p>
<p>This includes, but may not be limited to:</p>
<ul>
<li><a href="https://www.cloudflare.com/">Cloudflare</a> to protect against common threats and enhance our infrastructure</li>
<li><a href="www.hetzner.com/">Hetzner</a> as server and backup storage provider (located in Germany)</li>
<li><a href="https://translate.google.com/">Google Translate</a> to offer translations on our website</li>
<li><a href="https://opencollective.org/">OpenCollective</a>, <a href="https://liberapay.com/">Liberapay</a> and <a href="https://www.paypal.com/">Paypal</a> to allow the collection of donations that sustain our infrastructure</li>
</ul>
<h2 id="cookies"><a class="header" href="#cookies">Cookies</a></h2>
<p>Our Site may use “cookies” to enhance User experience. User’s web browser places cookies on their hard drive for record-keeping purposes and sometimes to track information about them. The user may choose to set their web browser to refuse cookies or to alert you when cookies are being sent. If they do so, note that some parts of the Site may not function properly.</p>
<h2 id="sharing-your-personal-information"><a class="header" href="#sharing-your-personal-information">Sharing your personal information</a></h2>
<p>We do not sell, trade, or rent User’s personal identification information to others.</p>
<h2 id="how-long-do-we-retain-your-data"><a class="header" href="#how-long-do-we-retain-your-data">How long do we retain your data</a></h2>
<p>If you leave a comment, the comment and its metadata are retained indefinitely. This is so we can recognize and approve any follow-up comments automatically instead of holding them in a moderation queue.</p>
<p>For users that register on our website (if any), we also store the personal information they provide in their user profile. All users can see, edit, or delete their personal information at any time (except they cannot change their username). Website administrators can also see and edit that information.</p>
<h2 id="embedded-content-from-other-websites"><a class="header" href="#embedded-content-from-other-websites">Embedded content from other websites</a></h2>
<p>Articles on this site may include embedded content (e.g. videos, images, articles, etc.). Embedded content from other websites behaves in the exact same way as if the visitor has visited the other website.</p>
<p>These websites may collect data about you, use cookies, embed additional third-party tracking, and monitor your interaction with that embedded content, including tracing your interaction with the embedded content if you have an account and are logged in to that website.</p>
<h2 id="free-software"><a class="header" href="#free-software">Free software</a></h2>
<p>Garuda Linux develops free software. All our tools are and will always be free software. Garuda Linux is part of OIN since November 2020. The current license can be viewed here. Additional information about packages covered by this license can be viewed here.</p>
<p>If you want to check the license of a package, you can do so with Pacman.</p>
<h2 id="what-rights-you-have-over-your-data"><a class="header" href="#what-rights-you-have-over-your-data">What rights you have over your data</a></h2>
<p>If you have an account on this site or have left comments, you can request to receive an exported file of the personal data we hold about you, including any data you have provided to us. You can also request that we erase any personal data we hold about you. This does not include any data we are obliged to keep for administrative, legal, or security purposes.</p>
<h2 id="childrens-information"><a class="header" href="#childrens-information">Children's Information</a></h2>
<p>Another part of our priority is adding protection for children while using the internet. We encourage parents and guardians to observe, participate in, and/or monitor and guide their online activity.</p>
<p>Garuda Linux does not knowingly collect any personal identifiable information from children under the age of 13. If you think that your child provided this kind of information on our website, we strongly encourage you to contact us immediately and we will do our best efforts to promptly remove such information from our records.</p>
<h2 id="changes-to-this-privacy-policy"><a class="header" href="#changes-to-this-privacy-policy">Changes to This Privacy Policy</a></h2>
<p>We may update our Privacy Policy from time to time. Thus, we advise you to review this page periodically for any changes. We will notify you of any
changes by posting the new Privacy Policy on this page. These changes are effective immediately, after they are posted on this page.</p>
<h2 id="your-acceptance-of-these-terms"><a class="header" href="#your-acceptance-of-these-terms">Your acceptance of these terms</a></h2>
<p>By using this Site, you signify your acceptance of this policy. If you do not agree to this policy, please do not use our services. Your continued use of them following the posting of changes to this policy will be deemed your acceptance of those changes.</p>
<h2 id="contact-us"><a class="header" href="#contact-us">Contact Us</a></h2>
<p>If you have any questions about this Privacy Policy, the practices of this site, or your dealings with this site, please contact us via <a href="mailto:team@garudalinux.org">email</a>.</p>
<p><strong>This privacy policy has been updated in September 2023.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="security-policy"><a class="header" href="#security-policy">Security Policy</a></h1>
<p>If any vulnerability or security flaw is discovered please contact us directly via <a href="mailto:team@garudalinux.org">team@garudalinux.org</a>.</p>
<p>We will try to respond within 24-48 hours on a best-effort basis.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="credits"><a class="header" href="#credits">Credits</a></h1>
<ul>
<li><a href="https://github.com/mozilla">https://github.com/mozilla</a></li>
<li><a href="https://github.com/JetBrains/JetBrainsMono">https://github.com/JetBrains/JetBrainsMono</a></li>
<li><a href="https://github.com/nix-community/infra">https://github.com/nix-community/infra</a></li>
<li><a href="https://github.com/BackInBash/RPIPv6">https://github.com/BackInBash/RPIPv6</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>